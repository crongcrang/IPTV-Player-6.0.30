<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IPTV Player</title>
	<script src="./assets/jwplayer/jwplayer.js"></script>
	<script type="text/javascript">jwplayer.key = 'XSuP4qMl+9tK17QNb+4+th2Pm9AWgMO/cYH8CI0HGGr7bdjo';</script>
    <link href="https://fonts.googleapis.com/css2?family=Prompt:wght@400;500;700&family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    :root {
    --primary: #1e88e5; /* สีน้ำเงินเข้ม */
    --secondary: #ff7043; /* สีส้มอ่อน */
    --background: #121212;
    --text: #ffffff;
}
    body { 
        margin: 0; 
        padding: 0; 
        background-color: var(--background); 
        color: var(--text);
        font-family: 'Prompt', 'Roboto', 'Arial', sans-serif; 
        display: flex; 
        flex-direction: column; 
        height: 100vh; 
        overflow: hidden; 
    }
	h1 {
    font-size: 28px;
    font-weight: 700;
}
.group, .channel {
    font-size: 16px;
    font-weight: 500;
}
.editable-name, .editable-group-name {
    font-size: 14px;
}
	
#header {
    background: linear-gradient(90deg, #1e88e5 0%, #ff7043 100%); /* ปรับ gradient ให้สว่างและสดขึ้น */
    padding: 10px 20px; /* เพิ่ม padding เพื่อความสมดุล */
    display: flex;
    justify-content: space-between; /* จัดให้ช่องค้นหาและไอคอนอยู่ขวา */
    align-items: center;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3); /* เพิ่มเงาด้านล่าง */
}
    #header h1 { 
        margin: 0; 
        font-size: 26px; 
        font-weight: bold; 
        letter-spacing: 1px; 
        flex: 0 0 auto; 
    }
#news-ticker {
    width: 90%; /* ปรับความกว้างให้เล็กลงเล็กน้อย */
    background: rgba(0, 0, 0, 0.8); /* พื้นหลังโปร่งแสงเข้ม */
    color: #fff;
    padding: 5px 10px; /* padding เพื่อความสมดุล */
    border-radius: 20px; /* ขอบมน */
    overflow: hidden;
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.5); /* เงาใน */
}
#news-ticker marquee {
    width: 100%;
    color: #ddd; /* สีเทาอ่อนเพื่อให้ดูนุ่มนวล */
    font-size: 14px; /* ขนาดตัวอักษรเล็กลง */
    transition: color 0.3s; /* เอฟเฟกต์สี */
}
#news-ticker marquee:hover {
    color: #ffcc00; /* สีเหลืองเมื่อ hover */
    text-shadow: 0 0 5px rgba(255, 204, 0, 0.8); /* เงาเหลือง */
    animation-play-state: paused; /* หยุดเลื่อนเมื่อ hover */
}
#news-ticker marquee a {
    color: #00ccff; /* สีน้ำเงินสำหรับลิงก์ */
    text-decoration: none; /* ลบขีดเส้นใต้ */
    transition: color 0.3s;
}
#news-ticker marquee a:hover {
    color: #ffcc00; /* สีเหลืองเมื่อ hover */
    text-decoration: underline; /* เพิ่มขีดเส้นใต้เมื่อ hover */
}
#search-bar {
    display: flex;
    align-items: center;
    gap: 10px; /* ระยะห่างระหว่างไอคอนและช่องค้นหา */
    width: auto; /* ลบ width: 50% เพื่อให้ยืดหยุ่น */
    background: rgba(255, 255, 255, 0.1); /* พื้นหลังโปร่งแสง */
    padding: 5px 10px; /* padding เพื่อให้ดูกลมกลืน */
    border-radius: 25px; /* ขอบมนมากขึ้น */
    box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2); /* เงาในเพื่อมิติ */
}
#search-input {
  padding: 8px 12px;
  border: none;
  border-radius: 20px;
  background: #333;
  color: #fff;
  width: 90px;
  outline: none;
  transition: width 0.3s ease, background 0.3s ease;
}
#search-input:focus {
    width: 90px; /* ขยายเมื่อโฟกัส */
    background: #444; /* สีเข้มขึ้นเมื่อโฟกัส */
    box-shadow: 0 0 5px rgba(30, 136, 229, 0.5); /* เงาสีน้ำเงิน */
}
#clear-search {
    cursor: pointer;
    font-size: 18px;
    padding: 5px;
}
#search-bar span {
    font-size: 20px; /* ขนาดไอคอน */
    cursor: pointer;
    padding: 6px; /* padding รอบไอคอน */
    border-radius: 50%; /* วงกลม */
    color: #fff; /* สีขาว */
    transition: color 0.3s, transform 0.2s, background 0.3s; /* เอฟเฟกต์ */
}
#search-bar span:last-child {
    margin-right: 0; /* ลบ margin ขวาของไอคอนตัวสุดท้าย */
}
    #search-icon, #files-icon, #youtube-icon, #open-file-icon, #open-stream-icon,
#sort-asc-btn, #sort-desc-btn, #sort-default-btn, #view-toggle {
    font-size: 24px;
    cursor: pointer;
    padding: 5px;
    transition: color 0.3s, transform 0.2s; /* รวม transition สองอย่าง */
}

#search-bar span:hover {
    color: #ffcc00; /* สีเหลืองเมื่อ hover */
    transform: scale(1.2); /* ขยายเล็กน้อย */
    background: rgba(255, 255, 255, 0.2); /* พื้นหลังโปร่งแสงเมื่อ hover */
}
    #search-icon:hover, #files-icon:hover, #youtube-icon:hover { 
        color: #bbb; 
		transform: scale(1.2); 
    }
   #youtube-container { 
        display: none; 
        position: absolute; 
        top: 90px; 
        background: #1e1e1e; 
        padding: 10px; 
        border-radius: 5px; 
        box-shadow: 0px 4px 10px rgba(255, 255, 255, 0.1); 
        z-index: 100; 
    }
#search-input-container {
  display: none;
  opacity: 0;
  transform: translateY(-10px);
  transition: opacity 0.2s ease, transform 0.2s ease;
}
#search-input-container.active {
  display: block;
  opacity: 1;
  transform: translateY(0);
}
#files-container {
    display: none;
    position: absolute;
    top: 60px; /* ปรับตำแหน่งให้เหมาะสม */
    right: 20px;
    background: #1e1e1e;
    padding: 10px;
    border-radius: 5px;
    box-shadow: 0px 4px 10px rgba(255, 255, 255, 0.1);
    z-index: 100;
    max-height: 300px;
    overflow-y: auto;
    width: 300px; /* กำหนดความกว้างให้เหมาะสม */
}
    #youtube-container { 
        right: 20px; 
    }
    #youtube-input { 
        padding: 8px; 
        border: none; 
        border-radius: 3px; 
        background: #333; 
        color: #fff; 
        width: 200px; 
        outline: none; 
    }
    #close-search, #close-youtube { 
        margin-left: 10px; 
        padding: 8px 15px; 
        background: #ff4444; 
        border: none; 
        border-radius: 3px; 
        color: #fff; 
        cursor: pointer; 
        transition: background 0.3s; 
    }
    #close-search:hover, #close-youtube:hover { 
        background: #cc0000; 
    }
    #play-youtube { 
        margin-left: 10px; 
        padding: 8px 15px; 
        background: #007bff; 
        border: none; 
        border-radius: 3px; 
        color: #fff; 
        cursor: pointer; 
        transition: background 0.3s; 
    }
    #play-youtube:hover { 
        background: #0056b3; 
    }
#container {
    display: flex;
    flex: 1;
    overflow: hidden;
    margin-bottom: 55px; /* เพิ่ม margin ด้านล่าง */
}
#group-list {
    display: flex;
    flex-direction: column;
    gap: 4px; /* ระยะห่างระหว่างกลุ่ม */
    background-color: #1e1e1e; /* พื้นหลังธีมมืด */
    padding: 8px 0;
    max-height: calc(100vh - 100px); /* ลดความสูงลง */
    overflow-y: auto; /* เปิดการเลื่อนในแนวตั้ง */
    scrollbar-width: none; /* ซ่อน scrollbar ใน Firefox */
    -ms-overflow-style: none; /* ซ่อน scrollbar ใน IE/Edge */
}
#group-list::-webkit-scrollbar {
    display: none;
}
    #group-list::-webkit-scrollbar, #channel-list::-webkit-scrollbar { 
        display: none; 
    }
    #group-list, #channel-list { 
        -ms-overflow-style: none; 
        scrollbar-width: none; 
    }
.group {
    padding: 6px 10px; /* ลด padding เพื่อให้แคบลง */
    cursor: pointer;
    display: flex;
    align-items: center;
    background-color: #2d2d2d;
    color: #ffffff;
    width: 180px; /* กำหนดความกว้างคงที่ให้แคบลง (ปรับได้ตามต้องการ) */
    margin-right: 5px;	/* ระยะห่างด้านขวาเพื่อไม่ให้ชิดขอบ */
	margin-left: 5px;
}

.group:hover {
    background-color: #3c3c3c;
}
    #channel-container {
    position: relative; /* เพื่อให้ #welcome-message วางทับได้ */
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}
    #channel-list {
    flex: 1;
    padding: 10px;
    display: flex; /* เปลี่ยนจาก absolute เป็น flex */
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
    align-content: flex-start;
    min-height: 100px;
    overflow-y: auto;
    height: calc(100vh - 150px); /* ปรับความสูง */
    transition: all 0.3s ease-in-out;
}

    }
#channel-list.list-view {
    display: flex;
    flex-direction: column;
    padding-left: 20px; /* เพิ่มระยะห่างด้านซ้าย */
    padding-right: 20px; /* เพิ่มระยะห่างด้านขวา */
    align-items: flex-start;
    gap: 5px;
    justify-content: flex-start;
    flex-wrap: nowrap;
}
   .channel {
    cursor: pointer;
    padding: 10px;
    background: #1e1e1e;
    display: block; /* หรือ flex ถ้าใช้ภายใน flexbox */
    border-radius: 8px;
    text-align: center;
    width: 80px;
    transition: transform 0.2s ease-in-out, background 0.3s ease-in-out, width 0.3s ease-in-out;
    flex-shrink: 0; /* ป้องกันไม่ให้บีบตัวเมื่ออยู่ใน flexbox */
    margin: 5px;
    cursor: move;
    user-select: none;
	 position: relative;
    z-index: 0;
}

   #channel-list.list-view .channel {
    width: 100%; /* ให้ช่องกว้างเต็มพื้นที่ที่เหลือ */
    display: flex;
    align-items: center;
    padding: 10px;
	text-align: left;
    box-sizing: border-box; /* รวม padding ในขนาดความกว้าง */
}
    .channel img {
        width: 60px;
        height: 60px;
        margin-bottom: 5px;
        border-radius: 50%;
        border: 2px solid #444;
    }
    #channel-list.list-view .channel img {
        margin-bottom: 0;
        margin-right: 10px;
        width: 40px;
        height: 40px;
    }
    .channel:hover {
        background: #333;
        transform: scale(1.05);
    }
	#channel-list.grid-view .channel {
    width: 100px;
    padding: 15px;
}
#channel-list.list-view .channel {
    display: flex;
    align-items: center;
    padding: 10px;
}
#channel-list.list-view .channel::after {
    content: attr(data-group);
    margin-left: 10px;
    color: #bbb;
    font-size: 12px;
}
	
	
    #view-toggle {
        font-size: 24px;
        cursor: pointer;
        padding: 5px;
        transition: color 0.3s;
    }
    #view-toggle:hover {
        color: #bbb;
    }
 #player-container {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: #000;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    transition: all 0.3s ease;
}
#player {
    position: relative;
    width: 100%;
    max-width: none;
    height: auto;
    border-radius: 10px;
    overflow: hidden;
    box-shadow: 0px 4px 10px rgba(255, 255, 255, 0.1);
}
    #embed-player { 
        width: 100%; 
        height: 100%; 
        max-height: none; 
        border: none; 
        border-radius: 10px; 
    }
    #player-container.fullscreen { 
        width: 100vw; 
        height: 100vh; 
        padding: 0; 
        margin: 0; 
    }
    #player-container.fullscreen #player,
    #player-container.fullscreen #embed-player { 
        width: 100vw; 
        height: 100vh; 
        border-radius: 0; 
    }
#player-controls {
    display: none; /* ซ่อนเริ่มต้น */
    justify-content: center;
    gap: 13px;
    padding: 10px;
    background: rgba(0, 0, 0, 0.8);
    border-radius: 8px;
    position: absolute;
    bottom: 20px; /* วางปุ่มควบคุมที่ด้านล่าง */
    opacity: 0; /* เริ่มต้นโปร่งใส */
    transition: opacity 0.3s ease; /* หน่วงเวลา fade in/out */
}
#player-container:hover #player-controls {
    display: flex; /* แสดงเมื่อ hover */
    opacity: 1; /* ทำให้มองเห็น */
}

#player-controls button {
    width: 30px;
    height: 30px;
    font-size: 15px;
    border-radius: 50%;
    background: #000;
    /* เพิ่ม 3 คุณสมบัติเหล่านี้เพื่อจัดให้เนื้อหาอยู่กลางปุ่ม */
    display: flex;
    align-items: center;
    justify-content: center;
}
#player-controls button:hover {
    background: #000;
}


#close-player {
    display: none; /* ซ่อนเริ่มต้น */
    padding: 5px;
    background: #555;
    border: none;
    border-radius: 10%;
    color: #fff;
    font-size: 16px;
    cursor: pointer;
    transition: opacity 0.3s ease, background 0.3s; /* เพิ่ม transition สำหรับ opacity */
    width: 30px;
    height: 30px;
    position: absolute;
    top: 10px;
    right: 10px;
    opacity: 0; /* เริ่มต้นโปร่งใส */
}

    #prev-channel, #stop-channel, #next-channel, #delete-btn, #favorite-btn {    
        cursor: pointer; 
    }


    #favorite-btn.active { 
        background: #000; 
        color: #ffcc00; 
    }

#player-container:hover #player-controls,
#player-container:hover #close-player {
    display: flex; /* แสดงเมื่อ hover */
    opacity: 1; /* ทำให้มองเห็น */
}

#close-player:hover {
    background: #f33; /* คงพฤติกรรม hover เดิม */
}

    #files-list div { 
        display: flex; 
        align-items: center; 
        padding: 5px; 
        border-radius: 5px; 
        transition: background 0.3s; 
    }
    #files-list div.selected { 
        background: #007bff; 
        border: 2px solid #0056b3; 
    }
    #files-list span { 
        flex: 1; 
        margin-right: 10px; 
        overflow: hidden; 
        text-overflow: ellipsis; 
        white-space: nowrap; 
    }
    .select-file-btn, .remove-file-btn { 
        padding: 5px 10px; 
        margin-left: 5px; 
        border: none; 
        border-radius: 3px; 
        cursor: pointer; 
        font-size: 16px; 
        transition: background 0.3s; 
    }
    .select-file-btn { 
        background: #28a745; 
        color: #fff; 
    }
    .select-file-btn:hover { 
        background: #218838; 
    }
.remove-file-btn {
    margin-left: 5px;
    padding: 2px 5px;
    background: #dc3545;
    color: #fff;
    border: none;
    border-radius: 3px;
    cursor: pointer;
    transition: background 0.3s;
}
.remove-file-btn:hover {
    background: #c82333;
}
    #sort-asc-btn, #sort-desc-btn { 
        font-size: 24px; 
        cursor: pointer; 
        padding: 5px; 
        transition: color 0.3s; 
    }
    #sort-asc-btn:hover, #sort-desc-btn:hover { 
        color: #bbb; 
    }
	#channel-list .welcome-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
    text-align: center;
    color: #bbb;
}
#channel-list .welcome-container img {
    max-width: 300px;
    max-height: 200px;
    margin-bottom: 20px;
    border-radius: 10px;
}
#channel-list .welcome-container p {
    font-size: 18px;
    margin: 0;
}
#channel-container {
    position: relative;
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}
#welcome-message {
    position: fixed; /* เปลี่ยนจาก absolute เป็น fixed เพื่อยึดกับหน้าต่าง */
    top: 0;
    left: 0;
    width: 100vw; /* ขยายเต็มความกว้างของ viewport */
    height: 100vh; /* ขยายเต็มความสูงของ viewport */
    background: #1e1e1e;
    z-index: 10;
    display: none; /* คงไว้เพื่อซ่อนตอนแรก */
}
#welcome-message .welcome-container {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%); /* จัดกึ่งกลางทั้งแนวนอนและแนวตั้ง */
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    color: #bbb;
    width: 90%; /* จำกัดความกว้างเพื่อป้องกันล้น */
    max-width: 600px; /* ขนาดสูงสุดของ container */
}
#welcome-message .welcome-container img {
    max-width: 300px;
    max-height: 200px;
    margin-bottom: 20px;
    border-radius: 10px;
}
#welcome-message .welcome-container p {
    font-size: 18px;
    margin: 0;
}
#sort-default-btn {
    font-size: 24px;
    cursor: pointer;
    padding: 5px;
    transition: color 0.3s;
}
#sort-default-btn:hover {
    color: #bbb;
}


.channel.dragging {
    opacity: 0.5; /* ลดความทึบเมื่อถูกลาก */
    background-color: #555; /* เปลี่ยนสีพื้นหลังเมื่อถูกลาก */
}


.editable-name {
    display: inline-block;
    min-width: 50px;
    padding: 2px 5px;
    border: 1px solid transparent;
    transition: border 0.3s;
    cursor: text;
}

.editable-name:focus {
    border: 1px solid #00ccff;
    outline: none;
    background: #333;
    border-radius: 3px;
}

#channel-list.list-view .editable-name {
    flex: 1;
    margin-left: 10px;
}
#open-folder-icon {
    font-size: 24px;
    cursor: pointer;
    padding: 5px;
    transition: color 0.3s, transform 0.2s;
}
#open-folder-icon:hover {
    color: #bbb;
    transform: scale(1.2);
}
.editable-group-name {
    display: inline-block;
    padding: 2px 5px;
    cursor: text;
    width: auto;
    min-width: 20px;
    border: 0px solid #555;
    border-radius: 3px;
    background-color: transparent;
    color: #ffffff;
}
.editable-group-name:hover {
    border-color: #888;
}
.editable-group-name:focus {
    outline: none;
    border: 1px solid #0078d4;
    background-color: #3c3c3c;
}
.group.active .editable-group-name {
    border-color: #fff;
    color: white;
}
.group.active .editable-group-name:hover {
    border-color: #ddd;
}
.group.active {
    background-color: #0078d4;
    color: white;
}
#footer {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    background: linear-gradient(90deg, #1e88e5 0%, #ff7043 100%); /* ปรับ gradient ให้สว่างและสดขึ้น */
    padding: 5px 0; /* ลด padding เพื่อความกระทัดรัด */
    height: 40px; /* ปรับความสูงให้เล็กลง */
    box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.3); /* เงาด้านบน */
    display: flex;
    align-items: center;
    justify-content: center; /* จัดกึ่งกลาง */
}
#metadata-display {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.7);
    padding: 15px;
    border-radius: 5px;
    color: #fff;
    font-size: 16px;
    text-align: center;
    z-index: 1000; /* เพิ่ม z-index ให้สูงกว่าเลเยอร์ของ JW Player */
    pointer-events: none;
    display: none; /* ซ่อนเริ่มต้น */
}
#metadata-display.active {
    display: block;
}
#metadata-display p {
    margin: 5px 0;
}

#metadata-display span {
    color: #bbb;
}
#player::before {
    content: "กำลังโหลด...";
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #fff;
    font-size: 20px;
    display: none;
}
#player.loading::before {
    display: block;
}
.group:focus, .channel:focus {
    outline: 2px solid #00ccff;
    outline-offset: 2px;
    background: #333;
}
#player-container:focus {
    outline: none; /* ไม่แสดง outline ใน Player */
}

.file-item {
    display: flex;
    align-items: center;
    padding: 8px;
    cursor: pointer;
    transition: background 0.2s;
}
.file-item:hover, .file-item:focus {
    background: #333;
    outline: 2px solid #00ccff;
    outline-offset: 2px;
}

.file-item.selected {
    background: #1e88e5;
}

.file-item span {
    flex: 1;
    margin-right: 10px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
}
.select-file-btn, .remove-file-btn {
    margin-left: 5px;
    padding: 2px 5px;
    cursor: pointer;
}

.select-file-btn:focus, .remove-file-btn:focus {
    outline: 2px solid #00ccff;
}
.custom-tooltip {
    z-index: 99999;
    background: #321;
    color: #fff;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 13px;
    white-space: nowrap;
    box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.3);
    position: absolute;
}
 #video-screenshot-btn { 
        
        cursor: pointer; 
        
    }


#delete-btn:hover {
    color: #ff0000; /* ตัวอักษร "D" เป็นสีแดงเมื่อ hover */
	cursor: crosshair; 
}


#video-screenshot-btn:hover {
    color: #00ff00; /* ตัวอักษร "C" เป็นสีเขียวเมื่อ hover */
	cursor: grab; 
}
        #video-player {
            width: 100%;
            height: 100%;
            max-height: none;
            border-radius: 10px;
            background: #000;
        }
#screenshot-preview-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.8);
    z-index: 2000;
    justify-content: center;
    align-items: center;
}

#screenshot-preview-container {
    background: #1e1e1e;
    padding: 20px;
    border-radius: 10px;
    text-align: center;
    box-shadow: 0 4px 10px rgba(255, 255, 255, 0.1);
}

#screenshot-preview-img {
    max-width: 400px;
    max-height: 300px;
    border-radius: 5px;
    margin-bottom: 15px;
}

#screenshot-preview-buttons {
    display: flex;
    justify-content: center;
    gap: 10px;
}

#screenshot-save-btn, #screenshot-cancel-btn {
    padding: 8px 15px;
    border: none;
    border-radius: 5px;
    color: #fff;
    cursor: pointer;
    transition: background 0.3s;
}

#screenshot-save-btn {
    background: #28a745;
}

#screenshot-save-btn:hover {
    background: #218838;
}

#screenshot-cancel-btn {
    background: #dc3545;
}

#screenshot-cancel-btn:hover {
    background: #c82333;
}
.channel img:hover {
    opacity: 0.8; /* ลดความทึบเมื่อ hover */
    cursor: pointer; /* เปลี่ยน cursor เป็น pointer */
}

.channel img.edit-mode-hover:hover {
    border: 2px dashed #00ccff; /* เส้นประสีน้ำเงินเมื่อ hover ในโหมดแก้ไข */
}
#image-upload-modal {
    transition: opacity 0.3s;
}

#image-upload-container {
    min-width: 350px;
}

#file-upload-section, #url-input-section {
    transition: display 0.2s;
}

#image-upload-input, #image-url-input {
    background: #333;
    color: #fff;
    padding: 5px;
    border-radius: 5px;
}

#image-upload-confirm:hover {
    background: #218838;
}

#image-upload-cancel:hover {
    background: #c82333;
}

input[type="radio"] {
    accent-color: #1e88e5; /* สีน้ำเงินสำหรับ radio button */
    cursor: pointer;
}
#download-btn:hover {
  color: #00ff00; /* สีเขียวเมื่อ hover */
  cursor: pointer;
}
#scroll-controls {
        position: absolute;
        right: 10px;
        top: 50%;
        transform: translateY(-50%);
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 50;
    }

    .scroll-btn {
        width: 40px;
        height: 40px;
        background: rgba(255, 255, 255, 0.1);
        border: none;
        border-radius: 50%;
        color: #fff;
        font-size: 20px;
        cursor: pointer;
        transition: background 0.3s, transform 0.2s;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .scroll-btn:hover {
        background: rgba(255, 255, 255, 0.3);
        transform: scale(1.1);
    }

    .scroll-btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
    }

</style>
</head>
<body>
    <div id="header">
   <!-- <h1>IPTV Player</h1> --!>
<div id="search-bar">
  <span id="clear-search" data-tooltip="ล้าง">🔍</span>
  <input type="text" id="search-input" placeholder="ค้นหาช่อง..." list="channel-suggestions" style="flex: 1; margin-right: 10px;">
  <datalist id="channel-suggestions"></datalist>
        
            <span id="open-folder-icon" data-tooltip="เปิดโฟลเดอร์">🗂️</span>
            <span id="open-file-icon" data-tooltip="เปิดไฟล์ในเครื่อง">📁</span>
            <span id="open-stream-icon" data-tooltip="เปิดสตรีมจาก URL">🌐</span>
			<span id="import-api-icon" data-tooltip="นำเข้าจาก Xtream Codes">📡</span>
            <span id="youtube-icon" data-tooltip="เล่น YouTube">▶️</span>
            <span id="sort-asc-btn" data-tooltip="เรียงช่อง A-Z">⬆️</span>
            <span id="sort-desc-btn" data-tooltip="เรียงช่อง Z-A">⬇️</span>
            <span id="sort-default-btn" data-tooltip="คืนค่าลำดับเริ่มต้น">🔄</span>
            <span id="view-toggle" data-tooltip="สลับมุมมอง Grid/List">🔡</span>
            <span id="files-icon" data-tooltip="เลือกไฟล์ที่ใช้">✅</span>
            <span id="edit-mode-btn" data-tooltip="แก้ไขชื่อช่อง/กลุ่ม">✏️</span>
			<span id="screenshot-btn" data-tooltip="จับภาพหน้าจอ">📸</span>      
    </div>
    </div>

    <div id="files-container">
        <div id="files-list"></div>
       
    </div>
    <div id="youtube-container">
        <input type="text" id="youtube-input" placeholder="วาง URL YouTube ที่นี่...">
        <input type="text" id="youtube-name" placeholder="ตั้งชื่อวิดีโอ (ไม่บังคับ)" style="margin-top: 5px; padding: 8px; border: none; border-radius: 3px; background: #333; color: #fff; width: 200px; outline: none;">
        <button id="play-youtube">เล่น</button>
        <button id="close-youtube">ปิด</button>
    </div>
    <div id="stream-input-container" style="display: none; position: absolute; top: 90px; right: 20px; background: #1e1e1e; padding: 10px; border-radius: 5px; box-shadow: 0px 4px 10px rgba(255, 255, 255, 0.1); z-index: 100;">
        <input type="text" id="stream-url-input" placeholder="วาง URL สตรีมที่นี่..." style="padding: 8px; border: none; border-radius: 3px; background: #333; color: #fff; width: 200px; outline: none;">
        <button id="play-stream" style="margin-left: 10px; padding: 8px 15px; background: #007bff; border: none; border-radius: 3px; color: #fff; cursor: pointer;">เล่น</button>
        <button id="close-stream" style="margin-left: 10px; padding: 8px 15px; background: #ff4444; border: none; border-radius: 3px; color: #fff; cursor: pointer;">ปิด</button>
    </div>
    <div id="import-url-container" style="display: none; position: absolute; top: 90px; right: 20px; background: #1e1e1e; padding: 10px; border-radius: 5px; box-shadow: 0px 4px 10px rgba(255, 255, 255, 0.1); z-index: 100;">
        <input type="text" id="import-url-input" placeholder="วาง URL ที่นี่..." style="padding: 8px; border: none; border-radius: 3px; background: #333; color: #fff; width: 200px; outline: none;">
        <button id="submit-url" style="margin-left: 10px; padding: 8px 15px; background: #007bff; border: none; border-radius: 3px; color: #fff; cursor: pointer;">นำเข้า</button>
        <button id="close-import-url" style="margin-left: 10px; padding: 8px 15px; background: #ff4444; border: none; border-radius: 3px; color: #fff; cursor: pointer;">ปิด</button>
    </div>
    <div id="container">
        <div id="group-list"></div>
        <div id="channel-container">
    <div id="channel-list"></div>
    <div id="scroll-controls">
        <button id="scroll-up-btn" class="scroll-btn" title="เลื่อนขึ้น">⬆️</button>
        <button id="scroll-down-btn" class="scroll-btn" title="เลื่อนลง">⬇️</button>
    </div>
    <div id="welcome-message" style="display: none;">
                <div class="welcome-container">
                    <img src="assets/tv-app.png" alt="Welcome" onerror="this.src='assets/tv-app.png'">
                    <p>ยินดีต้อนรับสู่ IPTV Player<br>กรุณานำเข้าไฟล์ช่องรายการเพื่อเริ่มใช้งาน<br>บริจาคสนับสนุนเพื่อพัฒนาโปรแกรมได้ที่ Paypal: sontaya.t@hotmail.com</p>
                </div>
            </div>
        </div>
    </div>
<div id="player-container">
    <div id="player">
        <div id="metadata-display" style="display: block;">
            <p id="metadata-title">ชื่อ: <span>กำลังโหลด...</span></p>
            <p id="metadata-bitrate">Bitrate: <span>ไม่ระบุ</span></p>
            <p id="metadata-codec">Codec: <span>ไม่ระบุ</span></p>
            <p id="metadata-duration">ระยะเวลา: <span>ไม่ระบุ</span></p>
        </div>
    </div>
	<video id="video-player" controls style="display: none;"></video>
    <iframe id="embed-player" style="display: none;"></iframe>
    <div id="player-controls">
        <span id="prev-channel" data-tooltip="ย้อนกลับ">⏪</span>
        <span id="stop-channel" data-tooltip="หยุด/เล่น">▶️</span>
        <span id="next-channel" data-tooltip="ช่องถัดไป">⏩</span>
        <span id="favorite-btn" data-tooltip="บันทึกช่องโปรด">F</span>
        <span id="delete-btn" data-tooltip="ลบช่องนี้">D</span>
		<span id="video-screenshot-btn" data-tooltip="จับภาพหน้าจอ">C</span>
		<span id="download-btn" data-tooltip="ดาวน์โหลดวิดีโอ">⬇️</span>
	</div>	
	
    <button id="close-player" data-tooltip="ปิด">✖</button>	
		
	
</div>

<script>
document.querySelectorAll("[data-tooltip]").forEach((el) => {
    el.addEventListener("mouseenter", function () {
        let tooltip = document.createElement("div");
        tooltip.className = "custom-tooltip";
        tooltip.textContent = el.getAttribute("data-tooltip");
        document.body.appendChild(tooltip);

        let rect = el.getBoundingClientRect();
        tooltip.style.position = "absolute";
        tooltip.style.top = `${rect.bottom + 5}px`;
        tooltip.style.left = `${rect.left + rect.width / 2}px`;
        tooltip.style.transform = "translateX(-50%)";
    });

    el.addEventListener("mouseleave", function () {
        document.querySelectorAll(".custom-tooltip").forEach((tooltip) => tooltip.remove());
    });
});
</script>


<script>
    let allChannels = [];
    let currentGroup = null;
    let currentChannelIndex = -1;
    let filteredChannels = [];
    let currentLanguage = 'th';
    let favoriteChannels = [];
    let importedFilesCache = [];
    let selectedFilePath = null;
    let originalFilteredChannels = [];
    let folderMedia = [];
	let isEditMode = false;

    const translations = {
        th: { title: 'IPTV Player', searchPlaceholder: 'ค้นหาช่อง...', close: 'ปิด', closePlayer: 'ปิด', noFiles: 'ไม่มีไฟล์ที่นำเข้า' },
        en: { title: 'IPTV Player', searchPlaceholder: 'Search channels...', close: 'Close', closePlayer: 'Close', noFiles: 'No imported files' }
    };

    function checkElectronAPI() {
        if (typeof window.electronAPI === 'undefined' || !window.electronAPI.openExternal) {
            console.error('electronAPI is undefined or incomplete');
            alert("Error: electronAPI is not properly initialized. Check preload.js");
            return false;
        }
        return true;
    }
	
function toggleEditMode() {
    isEditMode = !isEditMode;
    const editButton = document.getElementById("edit-mode-btn");
    editButton.textContent = isEditMode ? "💾" : "✏️";
    editButton.title = isEditMode 
        ? (currentLanguage === 'th' ? "บันทึกการแก้ไข" : "Save edits") 
        : (currentLanguage === 'th' ? "แก้ไขชื่อช่อง/กลุ่ม" : "Edit channel/group names");

    document.querySelectorAll(".editable-group-name, .editable-name").forEach(span => {
        span.contentEditable = isEditMode;
        span.title = isEditMode 
            ? (currentLanguage === 'th' ? "คลิกเพื่อแก้ไขชื่อ" : "Click to edit name") 
            : (currentLanguage === 'th' ? "กด ✏️ เพื่อแก้ไข" : "Press ✏️ to edit");
    });

    // เพิ่ม/ลบคลาสสำหรับรูปภาพ
    document.querySelectorAll(".channel img").forEach(img => {
        if (isEditMode) {
            img.classList.add("edit-mode-hover");
        } else {
            img.classList.remove("edit-mode-hover");
        }
    });

    console.log(`Edit mode: ${isEditMode}`);
}   
    function toggleWelcomeMessage() {
        const welcomeMessage = document.getElementById("welcome-message");
        const channelList = document.getElementById("channel-list");
        if (allChannels.length === 0) {
            welcomeMessage.style.display = "flex";
            channelList.style.display = "none";
            console.log("Showing welcome message: no channels available");
        } else {
            welcomeMessage.style.display = "none";
            channelList.style.display = "flex";
            console.log("Hiding welcome message: channels available");
        }
    }
    
    function toggleImportUrlPopup() {
        const importUrlContainer = document.getElementById("import-url-container");
        const importUrlInput = document.getElementById("import-url-input");

        if (importUrlContainer.style.display === "block") {
            importUrlContainer.style.display = "none";
            importUrlInput.value = "";
        } else {
            importUrlContainer.style.display = "block";
            importUrlInput.focus();
        }
    }

    function submitImportUrl() {
        const importUrlInput = document.getElementById("import-url-input");
        const url = importUrlInput.value.trim();

        if (!url) {
            alert(currentLanguage === 'th' ? "กรุณากรอก URL" : "Please enter a URL");
            return;
        }

        if (window.electronAPI && window.electronAPI.sendImportUrlResponse) {
            window.electronAPI.sendImportUrlResponse(url);
            toggleImportUrlPopup();
        } else {
            console.error("window.electronAPI.sendImportUrlResponse is not available");
        }
    }

    function toggleYouTubePopup() {
        const youtubeContainer = document.getElementById("youtube-container");
        const youtubeInput = document.getElementById("youtube-input");

        if (youtubeContainer.style.display === "block") {
            youtubeContainer.style.display = "none";
            youtubeInput.value = "";
        } else {
            youtubeContainer.style.display = "block";
            youtubeInput.focus();
        }
    }

    function playYouTubeVideo() {
        const youtubeInput = document.getElementById("youtube-input");
        const youtubeName = document.getElementById("youtube-name");
        const url = youtubeInput.value.trim();

        if (!url) {
            alert(currentLanguage === 'th' ? "กรุณากรอก URL YouTube" : "Please enter a YouTube URL");
            return;
        }

        let embedUrl;
        const videoIdMatch = url.match(/(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/i);
        if (!videoIdMatch || !videoIdMatch[1]) {
            alert(currentLanguage === 'th' ? "URL YouTube ไม่ถูกต้อง" : "Invalid YouTube URL");
            return;
        }

        const videoId = videoIdMatch[1];
        embedUrl = `https://www.youtube.com/embed/${videoId}?autoplay=1`;

        const thumbnailUrl = `https://img.youtube.com/vi/${videoId}/default.jpg`;
        const customName = youtubeName.value.trim();
        const shortName = customName || `YT: ${videoId.slice(0, 8)}`;

        const youtubeChannel = {
            name: shortName,
            file: embedUrl,
            embed: true,
            group: "YouTube",
            logo: thumbnailUrl || "default-youtube-logo.png"
        };

        document.getElementById("youtube-container").style.display = "none";
        youtubeInput.value = "";
        youtubeName.value = "";
        showPlayer(youtubeChannel, -1);
    }

    async function openFile() {
        if (window.electronAPI && window.electronAPI.openFileDialog) {
            try {
                const media = await window.electronAPI.openFileDialog();
                if (media) {
                    showPlayer(media, -1);
                }
            } catch (error) {
                console.error("Failed to open file:", error);
                alert(currentLanguage === 'th' ? "ไม่สามารถเปิดไฟล์ได้" : "Failed to open file");
            }
        } else {
            console.error("window.electronAPI.openFileDialog is not available");
        }
    }

    function toggleStreamPopup() {
        const streamContainer = document.getElementById("stream-input-container");
        const streamInput = document.getElementById("stream-url-input");

        if (streamContainer.style.display === "block") {
            streamContainer.style.display = "none";
            streamInput.value = "";
        } else {
            streamContainer.style.display = "block";
            streamInput.focus();
        }
    }

let currentStreamMedia = null; // ตัวแปรสำหรับเก็บข้อมูลสตรีม

function playStream() {
    const streamInput = document.getElementById("stream-url-input");
    const url = streamInput.value.trim();

    if (!url) {
        alert(currentLanguage === 'th' ? "กรุณากรอก URL สตรีม" : "Please enter a stream URL");
        return;
    }

    const media = {
        name: 'Stream ' + new Date().toLocaleTimeString(),
        file: url,
        group: 'Stream Media',
        logo: 'assets/tv-app.png',
        httpOptions: {
            referrer: "https://99dooball.com/",
            userAgent: "Mozilla/5.0 (Linux; Android 7.1.2; TV BOX Build/NHG47L) AppleWebKit/537.36 (KHTML เช่น Gecko) Chrome/56.0.2924.87 Safari/537.36"
        }
    };

    if (window.electronAPI && window.electronAPI.sendStreamUrl) {
        window.electronAPI.sendStreamUrl(url);
        toggleStreamPopup();
        currentStreamMedia = media;
        filteredChannels = [media];
        currentChannelIndex = 0;
        showPlayer(media, 0);
        console.log("Stream media initialized with URL:", media.file);
    } else {
        console.error("window.electronAPI.sendStreamUrl is not available");
    }
}
	
function showPlayer(channel, index) {
    const playerContainer = document.getElementById("player-container");
    const closePlayerBtn = document.getElementById("close-player");

    if (window.electronAPI && window.electronAPI.stopProxy) {
        window.electronAPI.stopProxy().then(() => {
            console.log("Proxy stopped for previous channel");
        }).catch((error) => {
            console.error(`Failed to stop proxy: ${error.message}`);
        });
    }

    playerContainer.style.display = "flex";
    document.getElementById("container").style.display = "none";
    currentChannelIndex = index >= 0 ? index : 0;
    console.log("Setting currentChannelIndex:", currentChannelIndex);

    // รีเซ็ต currentStreamMedia ถ้าไม่ใช่ Stream Media
    if (channel.group !== 'Stream Media') {
        currentStreamMedia = null;
        console.log("Reset currentStreamMedia as playing from channel list");
    } else {
        currentStreamMedia = channel;
    }

    // อัปเดต filteredChannels ตามบริบท
    if (currentGroup === (currentLanguage === 'th' ? "รายการโปรด" : "Favorites")) {
        filteredChannels = [...favoriteChannels]; // ใช้ favoriteChannels เมื่ออยู่ใน "รายการโปรด"
        console.log("Updated filteredChannels to favoriteChannels:", filteredChannels);
    } else if (channel.group !== 'Stream Media' && index >= 0) {
        filteredChannels = [...allChannels.filter(ch => ch.group === currentGroup)];
        console.log("Updated filteredChannels to match current group:", currentGroup);
    } else if (!filteredChannels.includes(channel)) {
        filteredChannels = [channel]; // เพิ่มช่องเข้า filteredChannels ถ้าไม่เจอ
        console.log("Added channel to filteredChannels:", filteredChannels);
    }

    playerContainer.tabIndex = 0;
    playerContainer.focus();
    playerContainer.onkeydown = handlePlayerKeydown;

    closePlayerBtn.innerText = "✖";
    closePlayerBtn.onclick = () => hidePlayer();

    document.getElementById("prev-channel").onclick = playPreviousChannel;
    document.getElementById("next-channel").onclick = playNextChannel;
    const stopChannelBtn = document.getElementById("stop-channel");
    stopChannelBtn.innerText = "▶️";
    stopChannelBtn.onclick = togglePlayPause;

    const favoriteBtn = document.getElementById("favorite-btn");
    favoriteBtn.onclick = () => toggleFavorite(channel);
    const isFavorite = favoriteChannels.some(fav => fav.file === channel.file);
    favoriteBtn.classList.toggle("active", isFavorite);

    const deleteBtn = document.getElementById("delete-btn");
    if (currentGroup !== (currentLanguage === 'th' ? "รายการโปรด" : "Favorites")) {
        showDeleteButton(channel);
    } else {
        deleteBtn.style.display = "none";
    }

    loadPlayer(channel).then(() => {
        console.log("Player loaded successfully for:", channel.name);
    }).catch(error => {
        console.error(`Failed to load player: ${error}`);
    });

    window.electronAPI.onWindowMaximized((isMaximized) => {
        adjustPlayerSize(isMaximized);
    });

    console.log("Showing player with channel:", channel, "at index:", index);
}




function handlePlayerKeydown(e) {
    if (e.key === "Escape") {
        hidePlayer();
        document.getElementById("channel-list").children[currentChannelIndex]?.focus(); // กลับไป Channel List
    } else if (e.key === "Space") {
        e.preventDefault();
        togglePlayPause();
    } else if (e.key === "ArrowLeft") {
        playPreviousChannel();
    } else if (e.key === "ArrowRight") {
        playNextChannel();
    } else if (e.key === "f" || e.key === "F") {
        toggleFavorite(filteredChannels[currentChannelIndex]);
    }
}	
	

    function togglePlayPause() {
        const stopChannelBtn = document.getElementById("stop-channel");
        const playerInstance = jwplayer("player");
        const currentState = playerInstance.getState();
        if (currentState === 'playing') {
            playerInstance.pause();
            stopChannelBtn.innerText = "▶️";
        } else {
            playerInstance.play();
            stopChannelBtn.innerText = "▶️";
        }
        isPlaying = currentState !== 'playing';
    }

function showDeleteButton(channel) {
    const deleteBtn = document.getElementById("delete-btn");
    deleteBtn.innerText = "D"; // หรือ "🗑️" ถ้าต้องการไอคอน
    deleteBtn.style.display = "inline-block"; // ทำให้ปุ่มแสดง
    deleteBtn.onclick = () => {
        const confirmMessage = currentLanguage === 'th' 
            ? `คุณแน่ใจว่าจะลบช่อง "${channel.name}"?` 
            : `Are you sure you want to delete the channel "${channel.name}"?`;
        const confirmed = confirm(confirmMessage);
        if (confirmed) {
            deleteChannel(channel);
        }
    };
}

    function playPreviousChannel() {
        if (currentChannelIndex > 0) {
            showPlayer(filteredChannels[currentChannelIndex - 1], currentChannelIndex - 1);
        }
    }

    function stopPlayer() {
        jwplayer("player").stop();
    }

    function playNextChannel() {
        if (currentChannelIndex < filteredChannels.length - 1) {
            showPlayer(filteredChannels[currentChannelIndex + 1], currentChannelIndex + 1);
        }
    }

function toggleFavorite(channel) {
    const index = favoriteChannels.findIndex(fav => fav.file === channel.file);
    if (index === -1) {
        const favoriteChannel = { ...channel };
        favoriteChannels.push(favoriteChannel);
        console.log(`Added ${favoriteChannel.name} to favorites with logo: ${favoriteChannel.logo}`);
    } else {
        favoriteChannels.splice(index, 1);
        console.log(`Removed ${channel.name} from favorites`);
    }
    if (window.electronAPI && typeof window.electronAPI.setFavorites === 'function') {
        window.electronAPI.setFavorites(favoriteChannels);
    } else {
        console.warn("window.electronAPI.setFavorites is not available. Favorite updated in cache only.");
    }
    const favoriteBtn = document.getElementById("favorite-btn");
    favoriteBtn.classList.toggle("active", index === -1);

    renderGroups();
    if (currentGroup === (currentLanguage === 'th' ? "รายการโปรด" : "Favorites")) {
        renderFavoriteChannels();
    }
}

    function deleteChannel(channel) {
        try {
            allChannels = allChannels.filter(ch => ch.file !== channel.file);
            favoriteChannels = favoriteChannels.filter(ch => ch.file !== channel.file);

            if (window.electronAPI && typeof window.electronAPI.setChannels === 'function') {
                window.electronAPI.setChannels(allChannels);
                console.log(`Sent updated channels to main process: ${allChannels.length} items`);
            } else {
                console.warn("window.electronAPI.setChannels is not available. Channel removed from cache only.");
            }

            if (window.electronAPI && typeof window.electronAPI.setFavorites === 'function') {
                window.electronAPI.setFavorites(favoriteChannels);
            } else {
                console.warn("window.electronAPI.setFavorites is not available. Favorite removed from cache only.");
            }

            hidePlayer();
            renderGroups();
            if (currentGroup) {
                renderChannels(currentGroup);
            } else {
                renderChannels("กลุ่มที่ไม่ระบุ");
            }

            console.log(`Channel "${channel.name}" deleted successfully.`);
        } catch (error) {
            console.error("Error during channel deletion:", error);
            hidePlayer();
            renderGroups();
            if (currentGroup) {
                renderChannels(currentGroup);
            }
        }
    }

function hidePlayer() {
  const playerContainer = document.getElementById("player-container");
  const metadataDisplay = document.getElementById("metadata-display");
  const videoPlayer = document.getElementById("video-player");
  const embedPlayer = document.getElementById("embed-player");
  const playerInstance = jwplayer("player");

  playerContainer.style.display = "none";
  document.getElementById("container").style.display = "flex";

  if (playerInstance.getState()) {
    playerInstance.stop();
    playerInstance.remove();
  }

  if (videoPlayer) {
    videoPlayer.pause();
    videoPlayer.currentTime = 0;
    videoPlayer.src = "";
    videoPlayer.load();
    videoPlayer.style.display = "none";
  }

  if (embedPlayer) {
    embedPlayer.style.display = "none";
    embedPlayer.src = "";
  }

  if (metadataDisplay) metadataDisplay.style.display = "none";

  isPlaying = true;
  document.getElementById("stop-channel").innerText = "⏹️";

  // หยุด Proxy เมื่อปิด player
  if (window.electronAPI && window.electronAPI.stopProxy) {
    window.electronAPI.stopProxy().then(() => {
      console.log("Proxy stopped on player close");
    }).catch((error) => {
      console.error(`Failed to stop proxy: ${error.message}`);
    });
  }
}

document.getElementById('video-screenshot-btn').addEventListener('click', async () => {
    try {
        console.log('Capturing screenshot...');
        
        // หา container ของ JW Player
        const jwContainer = document.getElementById('player');
        console.log('JW Player container found:', jwContainer);
        if (!jwContainer) {
            throw new Error('JW Player container not found. Expected ID: "player".');
        }

        // หา <video> ด้วย class "jw-video jw-reset"
        const videoElement = jwContainer.querySelector('video.jw-video.jw-reset');
        console.log('Video element inside JW Player:', videoElement);
        if (!videoElement) {
            throw new Error('No <video> element with class "jw-video jw-reset" found inside JW Player.');
        }

        // รอให้ <video> มีขนาด
        const getVisibleBounds = () => {
            return new Promise((resolve, reject) => {
                let attempts = 0;
                const maxAttempts = 50; // รอสูงสุด 5 วินาที
                const checkSize = () => {
                    const rect = videoElement.getBoundingClientRect();
                    const style = window.getComputedStyle(videoElement);
                    console.log('Checking video size, raw bounding rect:', rect);
                    console.log('Video computed style - display:', style.display, 'visibility:', style.visibility);
                    if (rect.width > 0 && rect.height > 0 && style.display !== 'none' && style.visibility !== 'hidden') {
                        resolve(rect);
                    } else if (attempts >= maxAttempts) {
                        reject(new Error('Video element has no visible size after waiting.'));
                    } else {
                        attempts++;
                        setTimeout(checkSize, 100);
                    }
                };
                checkSize();
            });
        };

        const rect = await getVisibleBounds();
        console.log('Full video rect:', rect);

        // หาความสูงของ control bar (ด้านล่าง)
        const controlBar = jwContainer.querySelector('.jw-controlbar');
        let controlBarHeight = 0;
        if (controlBar) {
            const controlBarRect = controlBar.getBoundingClientRect();
            controlBarHeight = controlBarRect.height;
            console.log('Control bar height:', controlBarHeight);
        } else {
            controlBarHeight = 20; // ค่าเริ่มต้น
            console.warn('Control bar not found, using default height:', controlBarHeight);
        }

        // หาความสูงของ logo และ title (ด้านบน)
        let topOffset = 0;
        const logoElement = jwContainer.querySelector('.jw-logo');
        const titleElement = jwContainer.querySelector('.jw-title');
        if (logoElement) {
            const logoRect = logoElement.getBoundingClientRect();
            topOffset = Math.max(topOffset, logoRect.height + (logoRect.top - rect.top));
            console.log('Logo height:', logoRect.height, 'top offset:', topOffset);
        }
        if (titleElement) {
            const titleRect = titleElement.getBoundingClientRect();
            topOffset = Math.max(topOffset, titleRect.height + (titleRect.top - rect.top));
            console.log('Title height:', titleRect.height, 'top offset:', topOffset);
        }
        if (topOffset === 0) {
            topOffset = 30; // ค่าเริ่มต้นถ้าไม่พบ logo หรือ title
            console.warn('Logo and title not found, using default top offset:', topOffset);
        }

        // คำนวณขอบด้านข้าง (letterbox/padding)
        const videoAspectRatio = 18 / 9; // สมมติวิดีโอเป็น 16:9
        const currentAspectRatio = rect.width / (rect.height - controlBarHeight - topOffset);
        let adjustedWidth = rect.width;
        let adjustedX = rect.x;
        if (currentAspectRatio > videoAspectRatio) {
            // มี letterbox ด้านข้าง
            adjustedWidth = (rect.height - controlBarHeight - topOffset) * videoAspectRatio;
            adjustedX = rect.x + (rect.width - adjustedWidth) / 2;
            console.log('Adjusting for letterbox: new width:', adjustedWidth, 'new x:', adjustedX);
        }

        // ปรับกรอบให้ครอบเฉพาะวิดีโอ
        const videoBounds = {
            x: Math.round(adjustedX),
            y: Math.round(rect.y + topOffset),
            width: Math.round(adjustedWidth),
            height: Math.round(rect.height - controlBarHeight - topOffset)
        };
        console.log('Adjusted video bounds (video only):', videoBounds);

        // จับภาพทั้งหน้าต่างก่อน
        const fullScreenshotData = await window.electronAPI.captureScreenshot();
        if (!fullScreenshotData) {
            throw new Error('No full screenshot data received');
        }
        console.log('Full screenshot captured, data length:', fullScreenshotData.length);

        // สร้าง <canvas> เพื่อครอบตัดภาพ
        const img = new Image();
        img.src = fullScreenshotData;
        await new Promise((resolve) => {
            img.onload = resolve;
        });

        const canvas = document.createElement('canvas');
        canvas.width = videoBounds.width;
        canvas.height = videoBounds.height;
        const ctx = canvas.getContext('2d');

        // ครอบตัดภาพตาม videoBounds
        ctx.drawImage(
            img,
            videoBounds.x,
            videoBounds.y,
            videoBounds.width,
            videoBounds.height,
            5,
            5,
            videoBounds.width,
            videoBounds.height
        );

        // แปลง canvas เป็น data URL
        const croppedScreenshotData = canvas.toDataURL('image/png');
        console.log('Cropped screenshot created, data length:', croppedScreenshotData.length);

        // แสดงภาพที่ครอบตัดแล้วใน modal
        const modal = document.getElementById('screenshot-preview-modal');
        const previewImg = document.getElementById('screenshot-preview-img');
        previewImg.src = croppedScreenshotData;
        modal.style.display = 'flex';

        document.getElementById('screenshot-save-btn').onclick = async () => {
            try {
                console.log('Saving screenshot...');
                const success = await window.electronAPI.saveScreenshot(croppedScreenshotData);
                modal.style.display = 'none';
                if (success) {
                    console.log('Screenshot saved successfully');
                } else {
                    console.log('Screenshot save cancelled');
                }
            } catch (error) {
                console.error('Failed to save screenshot:', error);
                alert('ไม่สามารถบันทึกภาพได้: ' + error.message);
            }
        };

        document.getElementById('screenshot-cancel-btn').onclick = () => {
            modal.style.display = 'none';
            console.log('Screenshot capture cancelled');
        };

        modal.onkeydown = (e) => {
            if (e.key === 'Escape') {
                modal.style.display = 'none';
            }
        };
    } catch (error) {
        console.error('Failed to capture screenshot:', error);
        alert('ไม่สามารถจับภาพหน้าจอได้: ' + error.message);
    }
});


async function loadPlayer(channel) {
    const logToMain = (message, level = "info") => {
        if (window.electronAPI && window.electronAPI.log) {
            window.electronAPI.log(message, level);
        } else {
            console.log(`[${level}] ${message}`);
        }
    };

    logToMain(`Starting loadPlayer for channel: ${channel.name}`);

    const playerContainer = document.getElementById("player-container");
    if (!playerContainer) {
        logToMain("Player container not found", "error");
        return;
    }

    const requiresProxy = channel.file.includes("dookeela.live") || channel.httpOptions?.referrer;

    if (requiresProxy) {
        try {
            const port = await window.electronAPI.startProxy(channel.file);
            logToMain(`Proxy started on port ${port} for ${channel.name}`);
        } catch (error) {
            logToMain(`Failed to start proxy: ${error.message}`, "error");
            updateMetadataDisplay(channel.name, "ไม่สามารถเริ่ม Proxy ได้", "N/A", "N/A");
            return;
        }
    }

    const playerDiv = document.getElementById("player");
    const embedPlayer = document.getElementById("embed-player");
    const videoPlayer = document.getElementById("video-player");
    const metadataDisplay = document.getElementById("metadata-display");

    if (!playerDiv || !embedPlayer || !videoPlayer) {
        logToMain("One or more player elements not found", "error");
        return;
    }

    let streamUrl = channel.file;
    let playerInstance;
    let refreshInterval = null;
    let retryCount = 0;
    const maxRetries = 3;

    if (typeof jwplayer !== "function") {
        logToMain("JW Player library not loaded", "error");
        updateMetadataDisplay(channel.name, "JW Player ไม่พร้อมใช้งาน", "N/A", "N/A");
        return;
    }

    playerInstance = jwplayer("player");

    // Reset player state
    playerDiv.style.display = "none";
    embedPlayer.style.display = "none";
    videoPlayer.style.display = "none";
    if (playerInstance.getState()) {
        playerInstance.stop();
        playerInstance.remove();
    }
    videoPlayer.pause();
    videoPlayer.src = "";
    playerDiv.classList.remove("audio-only");

    const updateMetadataDisplay = (title = "กำลังโหลด...", bitrate = "ไม่ระบุ", codec = "ไม่ระบุ", duration = "ไม่ระบุ") => {
        if (!metadataDisplay) {
            logToMain("Metadata display element not found", "warn");
            return;
        }
        const titleElement = metadataDisplay.querySelector("#metadata-title span");
        const bitrateElement = metadataDisplay.querySelector("#metadata-bitrate span");
        const codecElement = metadataDisplay.querySelector("#metadata-codec span");
        const durationElement = metadataDisplay.querySelector("#metadata-duration span");

        if (titleElement) titleElement.textContent = title || channel.name || "ไม่ระบุ";
        if (bitrateElement) bitrateElement.textContent = bitrate;
        if (codecElement) codecElement.textContent = codec;
        if (durationElement) durationElement.textContent = duration;

        metadataDisplay.style.display = "block";
        logToMain(`Metadata updated: ${title}, ${bitrate}, ${codec}, ${duration}`);
    };

    updateMetadataDisplay();

    async function getStreamUrl(initialUrl) {
        const isStreamUrl = (url) => /\.(m3u8|mpd|mp4|ts|mpeg|mpg|webm|mp3|aac|ogg|mkv)(\?.*)?$/i.test(url);
        let finalUrl = initialUrl;

        if (!initialUrl) {
            throw new Error("No stream URL provided");
        }

        if (initialUrl.includes('dookeela.live')) {
            logToMain(`Processing dookeela.live stream for ${channel.name}`);
            try {
                if (window.electronAPI && window.electronAPI.getM3u8) {
                    const response = await window.electronAPI.getM3u8(channel);
                    if (typeof response === "object" && response.url) {
                        finalUrl = response.url;
                        channel.drm = response.drm || channel.drm;
                    } else {
                        finalUrl = response;
                    }
                    if (!finalUrl || finalUrl.includes('#EXT-X-ERROR')) {
                        throw new Error(finalUrl?.split('\n')[1]?.split('.')[1]?.trim() || "Invalid .m3u8 response");
                    }
                    logToMain(`Electron API returned: ${JSON.stringify(response)}`);
                } else {
                    finalUrl = initialUrl;
                }
            } catch (error) {
                throw new Error(`Error fetching dookeela.live URL: ${error.message}`);
            }
        } else if (isStreamUrl(initialUrl)) {
            logToMain(`Direct stream URL detected: ${initialUrl}`);
            finalUrl = initialUrl;
        } else if (initialUrl.includes('youtube.com/embed')) {
            logToMain(`YouTube embed URL detected: ${initialUrl}`);
            finalUrl = initialUrl;
        } else {
            logToMain(`Using proxy for ${channel.name}: ${initialUrl}`);
            finalUrl = `http://localhost:9080/m3u8?url=${encodeURIComponent(initialUrl)}`;
        }
        return finalUrl;
    }

    async function loadStream(url) {
        try {
            streamUrl = await getStreamUrl(url);
            logToMain(`Final stream URL for ${channel.name}: ${streamUrl}`);

            const isMkv = streamUrl.match(/\.(mkv)(\?.*)?$/i);
            const isM3u8 = streamUrl.match(/\.(m3u8)(\?.*)?$/i) || streamUrl.includes('/m3u8');
            const isMpd = streamUrl.match(/\.(mpd)(\?.*)?$/i);
            const isMp4 = streamUrl.match(/\.(mp4)(\?.*)?$/i);
            const isMpeg = streamUrl.match(/\.(mpeg|mpg|ts)(\?.*)?$/i); // เพิ่มการตรวจสอบ MPEG
            const isYouTubeEmbed = streamUrl.includes('youtube.com/embed') || channel.embed;
            const isAudioOnly = streamUrl.match(/\.(mp3|aac|ogg)(\?.*)?$/i);

            if (isYouTubeEmbed) {
                embedPlayer.style.display = "block";
                embedPlayer.src = streamUrl;
                logToMain(`Embed player loaded for YouTube: ${streamUrl}`);
                document.getElementById("prev-channel").style.display = "none";
                document.getElementById("stop-channel").style.display = "none";
                document.getElementById("next-channel").style.display = "none";
                embedPlayer.onload = () => updateMetadataDisplay(channel.name, "YouTube Embed", "N/A", "N/A");
                embedPlayer.onerror = () => updateMetadataDisplay(channel.name, "ไม่สามารถโหลดได้", "N/A", "N/A");
                return;
            }

            if (isMkv || isMp4 || isMpeg) { // เพิ่ม isMpeg เข้าไป
                videoPlayer.style.display = "block";
                videoPlayer.src = streamUrl;
                videoPlayer.load();
                videoPlayer.play().catch(error => {
                    logToMain(`Failed to play ${isMpeg ? 'MPEG' : isMkv ? 'MKV' : 'MP4'}: ${error.message}`, "error");
                    updateMetadataDisplay(channel.name, "ไม่สามารถเล่นได้", "N/A", "N/A");
                });
                videoPlayer.onloadedmetadata = () => {
                    const duration = formatDuration(videoPlayer.duration);
                    updateMetadataDisplay(channel.name, "ไม่ระบุ", isMpeg ? "MPEG" : isMkv ? "MKV" : "MP4", duration);
                };
                videoPlayer.onplay = () => {
                    isPlaying = true;
                    document.getElementById("stop-channel").innerText = "⏹️";
                };
                videoPlayer.onpause = () => {
                    isPlaying = false;
                    document.getElementById("stop-channel").innerText = "▶️";
                };
                videoPlayer.onerror = () => {
                    logToMain(`Error playing ${isMpeg ? 'MPEG' : isMkv ? 'MKV' : 'MP4'} file: ${streamUrl}`, "error");
                    updateMetadataDisplay(channel.name, "เกิดข้อผิดพลาด", "N/A", "N/A");
                };
                return;
            }

            playerDiv.style.display = "block";
            embedPlayer.style.display = "none";
            document.getElementById("prev-channel").style.display = "inline-block";
            document.getElementById("stop-channel").style.display = "inline-block";
            document.getElementById("next-channel").style.display = "inline-block";

            const defaultLogo = "assets/tv-app.png";
            const channelLogo = channel.logo || defaultLogo;

            const mediaType = isM3u8 ? 'hls' : isMpd ? 'dash' : isAudioOnly ? 'mp3' : 'video/mpeg'; // ใช้ video/mpeg สำหรับกรณีที่ไม่รู้จัก
            logToMain(`Media type for ${channel.name}: ${mediaType}`);

            async function refreshM3u8() {
                try {
                    const newStreamUrl = await getStreamUrl(channel.file);
                    if (newStreamUrl !== streamUrl && playerInstance) {
                        logToMain(`Refreshing stream URL for ${channel.name}: ${newStreamUrl}`);
                        streamUrl = newStreamUrl;
                        playerInstance.load([{ file: streamUrl }]);
                        playerInstance.play();
                    }
                } catch (error) {
                    logToMain(`Failed to refresh .m3u8 for ${channel.name}: ${error.message}`, "error");
                }
            }

            const playerConfig = {
                file: streamUrl,
                type: mediaType,
                width: "100%",
                aspectratio: "16:9",
                autostart: true,
                controls: true,
                displaytitle: false,
                primary: "html5",
                playbackRateControls: true,
                playbackRates: [0.5, 1, 1.25, 1.5, 2],
                logo: {
                    file: channelLogo,
                    hide: true,
                    position: "top-left",
                    margin: 10,
                    link: null
                }
            };

            if (isAudioOnly) {
                playerConfig.image = channelLogo;
                playerDiv.classList.add("audio-only");
                playerDiv.style.backgroundImage = `url(${channelLogo})`;
            }

            if (channel.httpOptions && (channel.httpOptions.userAgent || channel.httpOptions.referrer)) {
                const userAgent = channel.httpOptions.userAgent || "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36";
                const referrer = channel.httpOptions.referrer || "https://dookeela.live/";
                playerConfig.hlsjsConfig = {
                    xhrSetup: (xhr) => {
                        xhr.setRequestHeader("User-Agent", userAgent);
                        xhr.setRequestHeader("Referer", referrer);
                        xhr.timeout = 10000;
                        logToMain(`HLS/DASH request for ${channel.name} - User-Agent: ${userAgent}, Referer: ${referrer}`);
                    },
                    maxBufferLength: 20,
                    maxMaxBufferLength: 30,
                    liveSyncDurationCount: 2,
                    liveMaxLatencyDurationCount: 5,
                    enableWorker: true,
                    startLevel: -1,
                    liveTimeout: 30,
                    liveDurationInfinity: true
                };
            }

            if (isMpd) {
                logToMain(`DRM info for ${channel.name}: ${JSON.stringify(channel.drm)}`);
                if (channel.drm && channel.drm.clearkey) {
                    playerConfig.drm = {
                        clearkey: {
                            keyId: channel.drm.clearkey.keyId,
                            key: channel.drm.clearkey.key
                        }
                    };
                    logToMain(`DRM ClearKey configured for ${channel.name}: ${JSON.stringify(playerConfig.drm)}`);
                } else {
                    logToMain(`No DRM info found for ${channel.name}, attempting to play without DRM`, "warn");
                }
            }

            playerInstance = jwplayer("player").setup(playerConfig);

            playerInstance.on("ready", () => {
                logToMain(`JW Player ready for ${channel.name}`);
                isPlaying = true;
                document.getElementById("stop-channel").innerText = "⏹️";
                playerInstance.setConfig({ logo: { hide: false } });
                if (channel.file.includes('dookeela.live') && isM3u8) {
                    refreshInterval = setInterval(refreshM3u8, 30000);
                    logToMain(`Started auto-refresh for ${channel.name} every 30 seconds`);
                }
            });

            playerInstance.on("play", () => {
                logToMain(`Playback started for ${channel.name}`);
                isPlaying = true;
                document.getElementById("stop-channel").innerText = "⏹️";
                playerInstance.setConfig({ logo: { hide: false } });
                if (isAudioOnly) {
                    playerDiv.style.backgroundImage = `url(${channelLogo})`;
                }
            });

            playerInstance.on("pause", () => {
                logToMain(`Playback paused for ${channel.name}`);
                isPlaying = false;
                document.getElementById("stop-channel").innerText = "▶️";
                playerInstance.setConfig({ logo: { hide: false } });
            });

            playerInstance.on("error", (error) => {
                logToMain(`JW Player error for ${channel.name}: ${error.message} (Code: ${error.code})`, "error");
                updateMetadataDisplay(channel.name, "เกิดข้อผิดพลาด", "N/A", "N/A");
                if (error.code === 202630 && retryCount < maxRetries) {
                    retryCount++;
                    logToMain(`Retry attempt ${retryCount} for ${channel.name}`);
                    setTimeout(() => loadStream(channel.file), 2000);
                }
            });

            playerInstance.on("setupError", (error) => {
                logToMain(`Setup error for ${channel.name}: ${error.message}`, "error");
                updateMetadataDisplay(channel.name, "ไม่สามารถตั้งค่าได้", "N/A", "N/A");
            });

            playerInstance.on("meta", (event) => {
                if (event.metadata) {
                    const bitrate = event.metadata.bitrate ? `${Math.round(event.metadata.bitrate / 1000)} kb/s` : "ไม่ระบุ";
                    const codec = event.metadata.codec || mediaType.toUpperCase();
                    const duration = event.metadata.duration ? `${Math.round(event.metadata.duration)} วินาที` : "ไม่ระบุ";
                    updateMetadataDisplay(channel.name, bitrate, codec, duration);
                }
            });
        } catch (error) {
            logToMain(`Failed to load stream for ${channel.name}: ${error.message}`, "error");
            updateMetadataDisplay(channel.name, "ไม่สามารถโหลดได้", "N/A", "N/A");
            if (retryCount < maxRetries) {
                retryCount++;
                logToMain(`Retry attempt ${retryCount} for ${channel.name}`);
                setTimeout(() => loadStream(channel.file), 2000);
            }
        }
    }

    function formatDuration(seconds) {
        if (!seconds || isNaN(seconds)) return "ไม่ระบุ";
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);
        return `${hours > 0 ? hours + " ชม. " : ""}${minutes} นาที ${secs} วินาที`;
    }

    try {
        await loadStream(streamUrl);
    } catch (error) {
        logToMain(`Initial loadStream failed: ${error.message}`, "error");
    }

    window.electronAPI.on('reload-stream', (event, url) => {
        logToMain(`Received reload-stream command for ${channel.name}: ${url}`);
        setTimeout(() => loadStream(url), 1000);
    });

    window.electronAPI.on('refresh-m3u8', (event, newM3u8Url) => {
        if (playerInstance && newM3u8Url !== streamUrl) {
            logToMain(`Received new .m3u8 from Proxy for ${channel.name}: ${newM3u8Url}`);
            streamUrl = newM3u8Url;
            playerInstance.load([{ file: streamUrl }]);
            playerInstance.play();
        }
    });

    window.addEventListener('unload', () => {
        if (refreshInterval) {
            clearInterval(refreshInterval);
            logToMain(`Stopped auto-refresh for ${channel.name}`);
        }
    });
}




		
    function renderChannels(groupOrSearch) {
        const channelList = document.getElementById("channel-list");
        channelList.innerHTML = "";

        if (typeof groupOrSearch === "string" && groupOrSearch.startsWith("search:")) {
            const query = groupOrSearch.replace("search:", "").toLowerCase();
            filteredChannels = allChannels.filter(ch => (ch.name || "").toLowerCase().includes(query));
        } else {
            currentGroup = groupOrSearch;
            filteredChannels = allChannels.filter(ch => (ch.group || "กลุ่มที่ไม่ระบุ") === groupOrSearch);
        }

        originalFilteredChannels = [...filteredChannels];
        renderChannelsFromFiltered();
    }


function renderFavoriteChannels() {
    const channelList = document.getElementById("channel-list");
    filteredChannels = favoriteChannels || [];

    if (filteredChannels.length === 0) {
        channelList.innerHTML = `
            <div class="welcome-container">
                <img src="assets/welcome-image.png" alt="Welcome" onerror="this.src='assets/tv-app.png'">
                <p>${currentLanguage === 'th' ? 'ยังไม่มีช่องโปรด<br>เพิ่มช่องโปรดเพื่อดูที่นี่' : 'No favorite channels yet<br>Add favorites to see them here'}</p>
            </div>
        `;
        console.log("No favorite channels, showing favorite welcome screen");
        return;
    }

    console.log("Rendering favorite channels:", filteredChannels.length);
    channelList.innerHTML = "";

    filteredChannels.forEach((channel, index) => {
        const defaultLogo = "assets/tv-app.png";
        const channelLogo = channel.logo || defaultLogo;

        const channelDiv = document.createElement("div");
        channelDiv.className = "channel";
        channelDiv.draggable = true;
        channelDiv.tabIndex = 0;
        channelDiv.dataset.index = index;

        const img = document.createElement("img");
        img.src = channelLogo.startsWith("data:image/") || channelLogo.startsWith("http") ? channelLogo : `file://${channelLogo}`;
        img.alt = channel.name;
        img.title = isEditMode 
            ? (currentLanguage === 'th' ? "คลิกเพื่อเปลี่ยนรูปภาพ" : "Click to change image") 
            : "";
        img.onerror = () => img.src = defaultLogo;

        img.addEventListener("click", (e) => {
            if (isEditMode) {
                e.stopPropagation();
                uploadChannelImage(channel, index, img);
            }
        });

        const nameSpan = document.createElement("span");
        nameSpan.textContent = channel.name || "ช่อง " + (index + 1);
        nameSpan.className = "editable-name";
        nameSpan.contentEditable = isEditMode;
        nameSpan.title = isEditMode 
            ? (currentLanguage === 'th' ? "คลิกเพื่อแก้ไขชื่อ" : "Click to edit name") 
            : (currentLanguage === 'th' ? "กด ✏️ เพื่อแก้ไข" : "Press ✏️ to edit");

        nameSpan.addEventListener("click", (e) => {
            if (isEditMode) e.stopPropagation();
        });
        nameSpan.addEventListener("blur", () => {
            if (isEditMode) {
                const newName = nameSpan.textContent.trim();
                if (newName && newName !== channel.name) {
                    console.log(`Updating favorite channel ${index} name from "${channel.name}" to "${newName}"`);
                    channel.name = newName;
                    updateFavoriteChannel(channel, index);
                    nameSpan.textContent = newName;
                }
            }
        });
        nameSpan.addEventListener("keydown", (e) => {
            if (e.key === "Enter" && isEditMode) {
                e.preventDefault();
                nameSpan.blur();
            }
        });

        channelDiv.appendChild(img);
        channelDiv.appendChild(document.createElement("br"));
        channelDiv.appendChild(nameSpan);
        channelDiv.onclick = (e) => {
            if (!isEditMode || (e.target !== nameSpan && e.target !== img)) {
                showPlayer(channel, index);
            }
        };
        channelDiv.onkeydown = (e) => handleChannelKeydown(e, channel, index);
        channelList.appendChild(channelDiv);
    });

    if (channelList.children.length > 0) channelList.children[0].focus();

    enableDragAndDrop();
}


function handleGroupKeydown(e, groupName) {
    const group = e.target;
    if (e.key === "Enter") {
        document.querySelectorAll(".group").forEach(g => g.classList.remove("active"));
        group.classList.add("active");
        currentGroup = groupName;
        if (groupName === (currentLanguage === 'th' ? "รายการโปรด" : "Favorites")) {
            renderFavoriteChannels();
        } else {
            renderChannels(groupName);
        }
        document.getElementById("channel-list").children[0]?.focus(); // โฟกัสช่องแรก
    } else if (e.key === "ArrowDown") {
        e.preventDefault();
        const nextGroup = group.nextElementSibling;
        if (nextGroup) nextGroup.focus();
    } else if (e.key === "ArrowUp") {
        e.preventDefault();
        const prevGroup = group.previousElementSibling;
        if (prevGroup) prevGroup.focus();
    }
}

function handleChannelKeydown(e, channel, index) {
    const channelDiv = e.target;
    const isGridView = !document.getElementById("channel-list").classList.contains("list-view");

    if (e.key === "Enter") {
        showPlayer(channel, index);
    } else if (e.key === "ArrowDown") {
        e.preventDefault();
        const nextChannel = isGridView ? getNextChannelGrid(channelDiv) : channelDiv.nextElementSibling;
        if (nextChannel) nextChannel.focus();
    } else if (e.key === "ArrowUp") {
        e.preventDefault();
        const prevChannel = isGridView ? getPrevChannelGrid(channelDiv) : channelDiv.previousElementSibling;
        if (prevChannel) prevChannel.focus();
    } else if (e.key === "ArrowRight" && isGridView) {
        e.preventDefault();
        const nextChannel = channelDiv.nextElementSibling;
        if (nextChannel) nextChannel.focus();
    } else if (e.key === "ArrowLeft" && isGridView) {
        e.preventDefault();
        const prevChannel = channelDiv.previousElementSibling;
        if (prevChannel) prevChannel.focus();
    }
}

function getNextChannelGrid(current) {
    const channels = Array.from(document.querySelectorAll(".channel"));
    const index = channels.indexOf(current);
    const cols = Math.floor(document.getElementById("channel-list").offsetWidth / 90); // ปรับตามความกว้างของช่อง
    return channels[index + cols] || null;
}

function getPrevChannelGrid(current) {
    const channels = Array.from(document.querySelectorAll(".channel"));
    const index = channels.indexOf(current);
    const cols = Math.floor(document.getElementById("channel-list").offsetWidth / 90);
    return channels[index - cols] || null;
}


    function updateChannel(channel, index) {
        console.log("Updating channel at index:", index, "with name:", channel.name);

        if (filteredChannels && index >= 0 && index < filteredChannels.length) {
            filteredChannels[index] = { ...channel };
        } else {
            console.warn("filteredChannels is invalid or index out of bounds:", filteredChannels, index);
        }

        const globalIndex = allChannels.findIndex(ch => ch.file === channel.file);
        if (globalIndex !== -1) {
            allChannels[globalIndex] = { ...channel };
        } else {
            console.warn("Channel not found in allChannels:", channel);
        }

        const favIndex = favoriteChannels.findIndex(ch => ch.file === channel.file);
        if (favIndex !== -1) {
            favoriteChannels[favIndex] = { ...channel };
        }

        if (window.electronAPI && typeof window.electronAPI.setChannels === 'function') {
            window.electronAPI.setChannels(allChannels);
            console.log(`Updated channel name in allChannels: ${channel.name}`);
        } else {
            console.warn("window.electronAPI.setChannels is not available. Channel updated in cache only.");
        }

        if (window.electronAPI && typeof window.electronAPI.setFavorites === 'function') {
            window.electronAPI.setFavorites(favoriteChannels);
            console.log(`Updated channel name in favoriteChannels: ${channel.name}`);
        } else {
            console.warn("window.electronAPI.setFavorites is not available. Favorite updated in cache only.");
        }
    }

    function updateFavoriteChannel(channel, index) {
        console.log("Updating favorite channel at index:", index, "with name:", channel.name);

        if (favoriteChannels && index >= 0 && index < favoriteChannels.length) {
            favoriteChannels[index] = { ...channel };
        } else {
            console.warn("favoriteChannels is invalid or index out of bounds:", favoriteChannels, index);
        }

        const globalIndex = allChannels.findIndex(ch => ch.file === channel.file);
        if (globalIndex !== -1) {
            allChannels[globalIndex] = { ...channel };
        }

        if (window.electronAPI && typeof window.electronAPI.setFavorites === 'function') {
            window.electronAPI.setFavorites(favoriteChannels);
            console.log(`Updated favorite channel name: ${channel.name}`);
        } else {
            console.warn("window.electronAPI.setFavorites is not available. Favorite updated in cache only.");
        }

        if (window.electronAPI && typeof window.electronAPI.setChannels === 'function') {
            window.electronAPI.setChannels(allChannels);
            console.log(`Synced channel name to allChannels: ${channel.name}`);
        } else {
            console.warn("window.electronAPI.setChannels is not available. Channel updated in cache only.");
        }
    }

  

function renderGroups() {
    const groupList = document.getElementById("group-list");
    groupList.innerHTML = "";
    
    const uniqueGroups = [...new Set(allChannels.map(ch => ch.group || "กลุ่มที่ไม่ระบุ"))];

    // แสดงกลุ่ม "รายการโปรด" เสมอ แม้ว่าจะว่างเปล่า
    const favGroup = document.createElement("div");
    favGroup.className = "group";
    favGroup.tabIndex = 0;
    const favNameSpan = document.createElement("span");
    favNameSpan.textContent = currentLanguage === 'th' ? "รายการโปรด" : "Favorites";
    favNameSpan.className = "editable-group-name";
    favNameSpan.contentEditable = isEditMode;
    favNameSpan.title = isEditMode 
        ? (currentLanguage === 'th' ? "คลิกเพื่อแก้ไขชื่อ" : "Click to edit name") 
        : (currentLanguage === 'th' ? "กด ✏️ เพื่อแก้ไข" : "Press ✏️ to edit");

    favNameSpan.addEventListener("click", (e) => {
        if (isEditMode) e.stopPropagation();
    });
    favNameSpan.addEventListener("blur", () => {
        if (isEditMode) {
            const newName = favNameSpan.textContent.trim();
            if (newName && newName !== (currentLanguage === 'th' ? "รายการโปรด" : "Favorites")) {
                updateGroupName(currentLanguage === 'th' ? "รายการโปรด" : "Favorites", newName);
                favNameSpan.textContent = newName;
            } else {
                favNameSpan.textContent = currentLanguage === 'th' ? "รายการโปรด" : "Favorites";
            }
        }
    });
    favNameSpan.addEventListener("keydown", (e) => {
        if (e.key === "Enter" && isEditMode) {
            e.preventDefault();
            favNameSpan.blur();
        }
    });

    favGroup.appendChild(favNameSpan);
    favGroup.onclick = (e) => {
        if (!isEditMode || e.target !== favNameSpan) {
            document.querySelectorAll(".group").forEach(g => g.classList.remove("active"));
            favGroup.classList.add("active");
            currentGroup = favNameSpan.textContent;
            renderFavoriteChannels();
        }
    };
    favGroup.onkeydown = (e) => handleGroupKeydown(e, favNameSpan.textContent);
    groupList.appendChild(favGroup);

    uniqueGroups.forEach(group => {
        const groupDiv = document.createElement("div");
        groupDiv.className = "group";
        groupDiv.tabIndex = 0;
        const nameSpan = document.createElement("span");
        nameSpan.textContent = group;
        nameSpan.className = "editable-group-name";
        nameSpan.contentEditable = isEditMode;
        nameSpan.title = isEditMode 
            ? (currentLanguage === 'th' ? "คลิกเพื่อแก้ไขชื่อ" : "Click to edit name") 
            : (currentLanguage === 'th' ? "กด ✏️ เพื่อแก้ไข" : "Press ✏️ to edit");

        nameSpan.addEventListener("click", (e) => {
            if (isEditMode) e.stopPropagation();
        });
        nameSpan.addEventListener("blur", () => {
            if (isEditMode) {
                const newName = nameSpan.textContent.trim();
                if (newName && newName !== group) {
                    updateGroupName(group, newName);
                    nameSpan.textContent = newName;
                } else if (!newName) {
                    nameSpan.textContent = group;
                }
            }
        });
        nameSpan.addEventListener("keydown", (e) => {
            if (e.key === "Enter" && isEditMode) {
                e.preventDefault();
                nameSpan.blur();
            }
        });

        groupDiv.appendChild(nameSpan);
        groupDiv.onclick = (e) => {
            if (!isEditMode || e.target !== nameSpan) {
                document.querySelectorAll(".group").forEach(g => g.classList.remove("active"));
                groupDiv.classList.add("active");
                currentGroup = nameSpan.textContent;
                renderChannels(nameSpan.textContent);
            }
        };
        groupDiv.onkeydown = (e) => handleGroupKeydown(e, nameSpan.textContent);
        groupList.appendChild(groupDiv);
    });

    if (currentGroup) {
        const activeGroup = [...groupList.children].find(g => g.textContent === currentGroup);
        if (activeGroup) activeGroup.classList.add("active");
    } else if (favoriteChannels.length > 0) {
        // ถ้ายังไม่มีกลุ่มที่เลือกและมีช่องโปรด ให้เลือก "รายการโปรด" เป็นค่าเริ่มต้น
        currentGroup = currentLanguage === 'th' ? "รายการโปรด" : "Favorites";
        groupList.children[0].classList.add("active");
        renderFavoriteChannels();
    }

    if (groupList.children.length > 0) groupList.children[0].focus();
}




    function updateGroupName(oldName, newName) {
        allChannels.forEach(channel => {
            if (channel.group === oldName) {
                channel.group = newName;
            }
        });
        window.electronAPI.setChannels(allChannels);
        renderGroups();
        if (currentGroup === oldName) {
            currentGroup = newName;
            renderChannels(newName);
        }
    }
	
	document.getElementById("clear-search").onclick = () => {
    document.getElementById("search-input").value = "";
    renderChannels(currentGroup);
};



function renderImportedFiles() {
    const filesList = document.getElementById("files-list");
    filesList.innerHTML = "";

    if (importedFilesCache.length === 0) {
        filesList.innerHTML = `<div style="color: #bbb; padding: 10px;">${translations[currentLanguage].noFiles}</div>`;
        return;
    }

    importedFilesCache.forEach((file, index) => {
        const fileDiv = document.createElement("div");
        fileDiv.className = "file-item";
        fileDiv.tabIndex = 0;

        const radioInput = document.createElement("input");
        radioInput.type = "radio";
        radioInput.id = `file-radio-${index}`;
        radioInput.name = "selected-file";
        radioInput.value = file.path;
        radioInput.checked = file.path === selectedFilePath; // ตรวจสอบว่าไฟล์นี้ถูกเลือกหรือไม่
        radioInput.style.marginRight = "10px";

        const fileSpan = document.createElement("span");
        fileSpan.textContent = file.name;
        fileSpan.title = file.path;

        const removeBtn = document.createElement("button");
        removeBtn.textContent = "✖";
        removeBtn.className = "remove-file-btn";
        removeBtn.title = currentLanguage === "th" ? "ลบไฟล์" : "Remove file";

        fileDiv.appendChild(radioInput);
        fileDiv.appendChild(fileSpan);
        fileDiv.appendChild(removeBtn);

        radioInput.onchange = () => {
            if (window.electronAPI && window.electronAPI.selectImportedFile) {
                window.electronAPI.selectImportedFile(file.path);
                selectedFilePath = file.path;
                console.log(`Selected file: ${file.path}`);
                // อัปเดต UI เพื่อให้ radio button อื่น ๆ ไม่ถูกเลือก
                renderImportedFiles();
            }
        };

        removeBtn.onclick = (e) => {
            e.stopPropagation();
            const confirmRemove = confirm(currentLanguage === "th" 
                ? `คุณแน่ใจหรือไม่ที่จะลบ "${file.name}"?` 
                : `Are you sure you want to remove "${file.name}"?`);
            if (confirmRemove && window.electronAPI && window.electronAPI.removeImportedFile) {
                window.electronAPI.removeImportedFile(file.path);
                if (file.path === selectedFilePath) {
                    selectedFilePath = null;
                }
                console.log(`Removed file: ${file.path}`);
            }
        };

        fileDiv.onkeydown = (e) => {
            if (e.key === "Enter" || e.key === " ") {
                e.preventDefault();
                radioInput.checked = true;
                radioInput.dispatchEvent(new Event("change"));
            }
        };

        filesList.appendChild(fileDiv);
    });

    // โฟกัสไปที่ไฟล์แรกถ้ามี
    if (filesList.children.length > 0) filesList.children[0].focus();
}

function handleFileKeydown(e, file, index) {
    const fileDiv = e.target;
    if (e.key === "Enter") {
        e.preventDefault();
        selectImportedFile(file.path); // เลือกไฟล์
        toggleFiles(); // ปิด popup หลังเลือก
    } else if (e.key === "ArrowDown") {
        e.preventDefault();
        const nextFile = fileDiv.nextElementSibling;
        if (nextFile) nextFile.focus();
    } else if (e.key === "ArrowUp") {
        e.preventDefault();
        const prevFile = fileDiv.previousElementSibling;
        if (prevFile) prevFile.focus();
    } else if (e.key === "Escape" || e.key === "Backspace") {
        e.preventDefault();
        toggleFiles(); // ปิด popup และกลับไปยังส่วนก่อนหน้า
    } else if (e.key === "Delete") {
        e.preventDefault();
        removeImportedFile(file.path); // ลบไฟล์
    }
}
let isImporting = false;
function toggleImportApiPopup() {
  const importApiContainer = document.getElementById("import-api-container");
  if (importApiContainer.style.display === "block") {
    importApiContainer.style.display = "none";
  } else {
    importApiContainer.style.display = "block";
    document.getElementById("xtreme-url").focus();
  }
}

// ในส่วน <script>
function updateApiOptions() {
    const apiSource = document.getElementById("api-source").value;
    const xtremeUrl = document.getElementById("xtreme-url");
    const xtremeUsername = document.getElementById("xtreme-username");
    const xtremePassword = document.getElementById("xtreme-password");
    const customUrl = document.getElementById("custom-url");

    xtremeUrl.style.display = "none";
    xtremeUsername.style.display = "none";
    xtremePassword.style.display = "none";
    customUrl.style.display = "none";

    if (apiSource === "xtreme") {
        xtremeUrl.style.display = "block";
        xtremeUsername.style.display = "block";
        xtremePassword.style.display = "block";
    } else if (apiSource === "pastebin" || apiSource === "freenote") {
        customUrl.style.display = "block";
    }
    // iptv-org-country ไม่ต้องกรอกข้อมูลเพิ่มเติม
}

function showProgressModal() {
    const modal = document.getElementById("import-progress-modal");
    modal.style.display = "block";
    isImporting = true;
}

function updateProgress(total, imported) {
    const modal = document.getElementById("import-progress-modal");
    const fill = document.getElementById("progress-fill");
    const text = document.getElementById("progress-text");

    if (!isImporting) return;

    const percentage = Math.round((imported / total) * 100);
    fill.style.width = `${percentage}%`;
    text.textContent = `${percentage}% (ประมวลผล ${imported}/${total} ช่อง)`;
}

function hideProgressModal() {
    const modal = document.getElementById("import-progress-modal");
    modal.style.display = "none";
    isImporting = false;
}


window.electronAPI.on("import-progress", (event, { total, imported }) => {
    updateProgress(total, imported);
});



window.electronAPI.on("import-start", () => {
    showProgressModal();
});

window.electronAPI.on("import-progress", (event, { total, imported }) => {
    updateProgress(total, imported);
});

window.electronAPI.on("import-complete", () => {
    hideProgressModal();
});

async function importChannelsFromApi() {
  const url = document.getElementById("xtreme-url").value.trim();
  const username = document.getElementById("xtreme-username").value.trim();
  const password = document.getElementById("xtreme-password").value.trim();

  if (!url || !username || !password) {
    alert(currentLanguage === "th" ? "กรุณากรอกข้อมูลให้ครบถ้วน" : "Please fill in all fields");
    return;
  }

  try {
    const channels = await window.electronAPI.importChannelsFromApi({
      apiSource: "xtreme",
      url,
      username,
      password,
    });
    console.log(`Imported ${channels.length} channels from Xtream Codes`);
    toggleImportApiPopup();
  } catch (error) {
    console.error("Failed to import from Xtream Codes:", error);
    alert(currentLanguage === "th" ? `นำเข้าล้มเหลว: ${error.message}` : `Import failed: ${error.message}`);
  }
}


function selectImportedFile(filePath) {
    console.log(`Selected file: ${filePath}`);
    selectedFilePath = filePath;
    if (window.electronAPI && typeof window.electronAPI.selectImportedFile === 'function') {
        window.electronAPI.selectImportedFile(filePath);
    } else {
        console.warn("window.electronAPI.selectImportedFile is not available");
    }
    // ปิด #files-container หลังเลือกไฟล์
    document.getElementById("files-container").style.display = "none";
    // กลับโฟกัสไปยัง Channel List หรือ Group List
    const channelList = document.getElementById("channel-list");
    if (channelList.children.length > 0 && currentChannelIndex >= 0) {
        channelList.children[currentChannelIndex]?.focus();
    } else {
        document.getElementById("group-list").children[0]?.focus();
    }
    renderImportedFiles(); // อัปเดต UI (ถ้าจำเป็น)
}

    function removeImportedFile(filePath) {
        console.log(`Removing file: ${filePath}`);
        if (window.electronAPI && typeof window.electronAPI.removeImportedFile === 'function') {
            window.electronAPI.removeImportedFile(filePath);
        } else {
            console.warn("window.electronAPI.removeImportedFile is not available");
        }
        importedFilesCache = importedFilesCache.filter(file => file.path !== filePath);
        if (selectedFilePath === filePath) selectedFilePath = null;
        renderImportedFiles();
    }
	
	
function toggleFiles() {
    const filesContainer = document.getElementById("files-container");
    if (filesContainer.style.display === "block") {
        filesContainer.style.display = "none";
    } else {
        renderImportedFiles();
        filesContainer.style.display = "block";
    }
}



	
async function downloadYouTubeVideo(videoId) {
    console.log("Starting YouTube download for videoId:", videoId);

    try {
        const { title, formats } = await window.electronAPI.getYouTubeFormats(videoId);
        console.log(`YouTube video: ${title}, formats:`, formats);

        const qualityModal = document.createElement("div");
        qualityModal.style.cssText = `
            position: fixed; 
            top: 50%; 
            left: 50%; 
            transform: translate(-50%, -50%); 
            background: #1e1e1e; 
            padding: 20px; 
            border-radius: 10px; 
            color: #fff; 
            z-index: 2000;
            box-shadow: 0 4px 10px rgba(255, 255, 255, 0.1);
        `;
        qualityModal.innerHTML = `
            <p>${currentLanguage === "th" ? "เลือกคุณภาพสำหรับ" : "Select quality for"} "${title}":</p>
            <select id="quality-select" style="width: 100%; padding: 5px; margin: 10px 0; background: #333; color: #fff; border: none; border-radius: 3px;">
                ${formats.map((f) => `<option value="${f.formatId}">${f.resolution} (${f.ext})</option>`).join("")}
            </select>
            <div style="display: flex; justify-content: center; gap: 10px;">
                <button id="download-btn" style="padding: 5px 10px; background: #28a745; border: none; border-radius: 5px; color: #fff; cursor: pointer;">${currentLanguage === "th" ? "ดาวน์โหลด" : "Download"}</button>
                <button id="cancel-btn" style="padding: 5px 10px; background: #dc3545; border: none; border-radius: 5px; color: #fff; cursor: pointer;">${currentLanguage === "th" ? "ยกเลิก" : "Cancel"}</button>
            </div>
        `;
        document.body.appendChild(qualityModal);

        const downloadBtn = qualityModal.querySelector("#download-btn");
        const cancelBtn = qualityModal.querySelector("#cancel-btn");
        const qualitySelect = qualityModal.querySelector("#quality-select");

        const { formatId, filePath } = await new Promise((resolve) => {
            downloadBtn.onclick = async () => {
                const formatId = qualitySelect.value;
                const defaultFileName = `${title.replace(/[\\/:*?"<>|]/g, "_")}.mp4`;
                const { canceled, filePath } = await window.electronAPI.invoke("show-save-dialog", {
                    defaultPath: defaultFileName,
                    filters: [{ name: "Video Files", extensions: ["mp4"] }],
                });

                if (!canceled && filePath) {
                    console.log("Selected format:", formatId, "Save path:", filePath);
                    document.body.removeChild(qualityModal);
                    resolve({ formatId, filePath });
                } else {
                    console.log("Save dialog cancelled");
                    resolve({ formatId: null, filePath: null });
                }
            };

            cancelBtn.onclick = () => {
                console.log("Quality selection cancelled");
                document.body.removeChild(qualityModal);
                resolve({ formatId: null, filePath: null });
            };
        });

        if (!formatId || !filePath) {
            console.log("YouTube download cancelled");
            return;
        }

        // แสดง Progress Modal
        let progressModal;
        let isDownloadCompleted = false;

        try {
            console.log("Creating progress modal for YouTube...");
            progressModal = document.createElement("div");
            progressModal.style.cssText = `
                position: fixed; 
                bottom: 20px; 
                right: 20px; 
                background: rgba(30, 30, 30, 0.8); 
                padding: 10px 15px; 
                border-radius: 5px; 
                color: #fff; 
                z-index: 2000; 
                font-size: 14px; 
                box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            `;
            progressModal.innerHTML = `
                <p style="margin: 0;">Downloading: <span id="download-progress">0%</span></p>
                <button id="stop-download-btn" style="margin-top: 5px; padding: 3px 8px; background: #dc3545; border: none; border-radius: 3px; color: #fff; cursor: pointer; font-size: 12px;">หยุด</button>
            `;
            document.body.appendChild(progressModal);
            console.log("Progress modal added to DOM");

            const stopButton = progressModal.querySelector("#stop-download-btn");
            let isStopping = false;
            stopButton.onclick = async () => {
                if (isStopping) return;
                isStopping = true;
                stopButton.disabled = true;
                stopButton.style.opacity = "0.5";
                console.log("Stop YouTube download button clicked");
                try {
                    await window.electronAPI.stopDownload();
                    console.log("Stop download requested");
                    document.body.removeChild(progressModal);
                } catch (error) {
                    console.error("Error stopping YouTube download:", error);
                    document.body.removeChild(progressModal);
                    showErrorModal(currentLanguage === "th" ? `หยุดดาวน์โหลดล้มเหลว: ${error.message}` : `Failed to stop download: ${error.message}`);
                }
            };

            console.log("Setting up event listeners for YouTube...");
            const onProgress = (progress) => {
                console.log("YouTube download progress received:", progress);
                if (document.getElementById("download-progress")) {
                    document.getElementById("download-progress").textContent = `${progress.percent}% (${progress.timemark})`;
                }
            };

            const onComplete = (filePath) => {
                if (isDownloadCompleted) return;
                isDownloadCompleted = true;
                console.log("YouTube download complete:", filePath);
                document.body.removeChild(progressModal);
                showSuccessModal(currentLanguage === "th" ? `ดาวน์โหลดสำเร็จ: ${filePath}` : `Download complete: ${filePath}`);
                cleanupListeners();
            };

            const onError = (error) => {
                if (isDownloadCompleted) return;
                console.error("YouTube download error received:", error);
                document.body.removeChild(progressModal);
                showErrorModal(currentLanguage === "th" ? `ดาวน์โหลดล้มเหลว: ${error}` : `Download failed: ${error}`);
                cleanupListeners();
            };

            window.electronAPI.onDownloadProgress(onProgress);
            window.electronAPI.onDownloadComplete(onComplete);
            window.electronAPI.onDownloadError(onError);

            function cleanupListeners() {
                window.electronAPI.off("download-progress", onProgress);
                window.electronAPI.off("download-complete", onComplete);
                window.electronAPI.off("download-error", onError);
                console.log("YouTube event listeners cleaned up");
            }

            console.log("Calling downloadYouTube with videoId:", videoId, "formatId:", formatId, "to:", filePath);
            const result = await window.electronAPI.downloadYouTube(videoId, formatId, filePath);
            console.log("YouTube download function completed with result:", result);
            if (!isDownloadCompleted) {
                onComplete(filePath);
            }
        } catch (error) {
            console.error("Error during YouTube download process:", error.message, error.stack);
            if (progressModal && document.body.contains(progressModal)) {
                document.body.removeChild(progressModal);
            }
            showErrorModal(currentLanguage === "th" ? `เกิดข้อผิดพลาด: ${error.message}` : `Error: ${error.message}`);
        }
    } catch (error) {
        console.error("Failed to fetch YouTube formats or start download:", error.message);
        showErrorModal(currentLanguage === "th" ? 
            `เกิดข้อผิดพลาดในการดาวน์โหลด YouTube: ${error.message}` : 
            `Error downloading YouTube: ${error.message}`);
        if (error.message.includes("yt-dlp")) {
            alert(currentLanguage === "th" ? 
                "ไม่พบ yt-dlp กรุณาตรวจสอบว่า yt-dlp.exe อยู่ในโฟลเดอร์ resources" : 
                "yt-dlp not found. Please ensure yt-dlp.exe is in the resources folder");
        }
    }
}
	
	
	
	
async function fetchNews() {
        const marquee = document.getElementById("news-marquee");
        if (!marquee) {
            console.error("News marquee element not found");
            return;
        }
        try {
            const response = await fetch("https://www.yourserver.com/news.txt", {
                cache: "no-store" // ป้องกันการแคช เพื่อให้ได้ข้อมูลล่าสุดเสมอ
            });
            const newsText = await response.text();
            if (marquee.textContent !== newsText.trim()) {
                marquee.textContent = newsText.trim();
                console.log("News updated: " + newsText);
            }
        } catch (error) {
            console.error("Failed to fetch news: " + error);
            marquee.textContent = currentLanguage === 'th' ? "ไม่สามารถดึงข่าวได้" : "Unable to fetch news";
        }
    }
	

    let channelsCache = null;

// ฟังก์ชัน debounce
function debounce(func, wait) {
  let timeout;
  return function (...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), wait);
  };
}

async function init() {
  // Event listeners อื่น ๆ คงไว้ตามเดิม
  document.getElementById("sort-asc-btn").onclick = () => sortChannels('asc');
  document.getElementById("sort-desc-btn").onclick = () => sortChannels('desc');
  document.getElementById("sort-default-btn").onclick = () => sortChannels('default');
  document.getElementById("files-icon").onclick = toggleFiles;
  document.getElementById("youtube-icon").onclick = toggleYouTubePopup;
  document.getElementById("open-file-icon").onclick = openFile;
  document.getElementById("open-stream-icon").onclick = toggleStreamPopup;
  document.getElementById("close-youtube").onclick = toggleYouTubePopup;
  document.getElementById("play-youtube").onclick = playYouTubeVideo;
  document.getElementById("submit-url").onclick = submitImportUrl;
  document.getElementById("close-import-url").onclick = toggleImportUrlPopup;
  document.getElementById("play-stream").onclick = playStream;
  document.getElementById("close-stream").onclick = toggleStreamPopup;
  document.getElementById("open-folder-icon").onclick = openFolder;
  document.getElementById("edit-mode-btn").onclick = toggleEditMode;
  document.getElementById("import-api-icon").onclick = toggleImportApiPopup;
  document.getElementById("import-api-btn").onclick = importChannelsFromApi;
  document.getElementById("close-import-api").onclick = toggleImportApiPopup;
  document.getElementById("scroll-up-btn").onclick = () => scrollChannelList('up');
  document.getElementById("scroll-down-btn").onclick = () => scrollChannelList('down');
  
  
  
  
  const searchInput = document.getElementById("search-input");
  const datalist = document.getElementById("channel-suggestions");

  // ตั้งค่า placeholder
  if (translations[currentLanguage]) {
    searchInput.placeholder = translations[currentLanguage].searchPlaceholder;
  }

const updateSuggestions = debounce((query) => {
  console.time("updateSuggestions");
  const lowerQuery = query.toLowerCase();
  const suggestions = allChannels
    .filter(ch => ch.name.toLowerCase().includes(lowerQuery))
    .slice(0, 10);
  datalist.innerHTML = suggestions
    .map(ch => `<option value="${ch.name}" data-group="${ch.group}">`)
    .join("");
  console.timeEnd("updateSuggestions");
}, 200);

  // เมื่อพิมพ์ในช่องค้นหา (อัปเดต suggestions เท่านั้น)
  searchInput.oninput = () => {
    const query = searchInput.value.trim();
    updateSuggestions(query); // อัปเดตแค่คำแนะนำ
  };

  // เมื่อกด Enter หรือเลือกจาก datalist (ค้นหาจริง)
  searchInput.onkeydown = (e) => {
    if (e.key === "Enter") {
      const query = searchInput.value.trim();
      if (query) renderChannels(`search:${query}`);
      else renderChannels(currentGroup || "กลุ่มที่ไม่ระบุ");
    }
  };

  searchInput.onchange = () => {
    const selectedOption = datalist.querySelector(`option[value="${searchInput.value}"]`);
    if (selectedOption) {
      const group = selectedOption.getAttribute("data-group");
      renderChannels(`search:${searchInput.value}`);
      console.log(`Selected channel: ${searchInput.value} from group: ${group}`);
    }
  };

  // ปุ่มล้าง
  document.getElementById("clear-search").onclick = () => {
    searchInput.value = "";
    datalist.innerHTML = "";
    renderChannels(currentGroup || "กลุ่มที่ไม่ระบุ");
  };

  // Event listeners อื่น ๆ คงไว้
  const viewToggle = document.getElementById("view-toggle");
  const channelList = document.getElementById("channel-list");
  channelList.addEventListener('scroll', updateScrollButtons);

  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape") {
      const filesContainer = document.getElementById("files-container");
      if (filesContainer.style.display === "block") {
        filesContainer.style.display = "none";
        document.getElementById("group-list").children[0]?.focus();
      } else if (document.getElementById("player-container").style.display === "flex") {
        hidePlayer();
        document.getElementById("channel-list").children[currentChannelIndex]?.focus();
      }
    }
  });

  // โหลดข้อมูลเริ่มต้น
  try {
    allChannels = await window.electronAPI.getChannels?.() || [];
    favoriteChannels = await window.electronAPI.getFavorites?.() || [];
    importedFilesCache = await window.electronAPI.getImportedFiles?.() || [];
    channelsCache = allChannels;

    console.log("Initial channels loaded:", allChannels.length);
    console.log("Initial favorites loaded:", favoriteChannels.length);
    console.log("Initial imported files loaded:", importedFilesCache.length);

    toggleWelcomeMessage();
    renderGroups();
    renderImportedFiles();
    if (allChannels.length > 0) {
      filteredChannels = [...allChannels];
      renderChannels("กลุ่มที่ไม่ระบุ");
      enableDragAndDrop();
    } else if (favoriteChannels.length > 0) {
      currentGroup = currentLanguage === 'th' ? "รายการโปรด" : "Favorites";
      renderFavoriteChannels();
    }
  } catch (error) {
    console.error("Failed to initialize data:", error);
  }

  // Electron API listeners คงไว้ตามเดิม
  if (window.electronAPI) {
    window.electronAPI.onShowImportUrlPopup(() => toggleImportUrlPopup());
    window.electronAPI.onChannelsUpdated((channels) => {
      console.log("Channels updated in renderer:", channels.length);
      allChannels = channels || [];
      channelsCache = allChannels;
      toggleWelcomeMessage();
      renderGroups();
      if (currentGroup === (currentLanguage === 'th' ? "รายการโปรด" : "Favorites")) {
        renderFavoriteChannels();
      } else {
        renderChannels(currentGroup || "กลุ่มที่ไม่ระบุ");
      }
      enableDragAndDrop();
    });
    window.electronAPI.onFavoritesUpdated((favorites) => {
      console.log("Favorites updated:", favorites.length);
      favoriteChannels = favorites || [];
      renderGroups();
      if (currentGroup === (currentLanguage === 'th' ? "รายการโปรด" : "Favorites")) {
        renderFavoriteChannels();
      } else if (!currentGroup && favoriteChannels.length > 0) {
        currentGroup = currentLanguage === 'th' ? "รายการโปรด" : "Favorites";
        renderFavoriteChannels();
      }
    });
    window.electronAPI.onImportedFilesUpdated((files) => {
      importedFilesCache = files;
      renderImportedFiles();
      console.log(`Imported files updated: ${files.length} items`);
    });
    window.electronAPI.onSelectedFileUpdated(async (filePath) => {
      console.log(`Selected file updated: ${filePath}`);
      selectedFilePath = filePath;
      try {
        allChannels = await window.electronAPI.getChannels();
        channelsCache = allChannels;
        filteredChannels = [...allChannels];
        currentGroup = null;
        toggleWelcomeMessage();
        renderGroups();
        renderChannels("กลุ่มที่ไม่ระบุ");
        enableDragAndDrop();
      } catch (error) {
        console.error("Failed to update channels after selecting file:", error);
      }
    });
    window.electronAPI.onMediaSelected((media) => {
      console.log(`Media selected: ${JSON.stringify(media)}`);
      showPlayer(media, -1);
    });
    window.electronAPI.on("import-start", () => {
      document.getElementById("import-progress-modal").style.display = "block";
      document.getElementById("progress-fill").style.width = "0%";
      document.getElementById("progress-text").textContent = "0%";
    });
    window.electronAPI.on("import-progress", (event, { total, imported }) => {
      const percentage = Math.round((imported / total) * 100);
      document.getElementById("progress-fill").style.width = `${percentage}%`;
      document.getElementById("progress-text").textContent = `${percentage}%`;
    });
    window.electronAPI.on("import-complete", () => {
      document.getElementById("import-progress-modal").style.display = "none";
    });
  }

  // View Toggle
  try {
    const savedMode = await window.electronAPI.getViewMode();
    if (savedMode === 'list') {
      channelList.classList.add("list-view");
      viewToggle.textContent = "🔤";
    }
    viewToggle.onclick = () => {
      channelList.classList.toggle("list-view");
      const mode = channelList.classList.contains("list-view") ? 'list' : 'grid';
      viewToggle.textContent = mode === 'list' ? "🔤" : "🔡";
      window.electronAPI.setViewMode(mode);
    };
  } catch (error) {
    console.error("Error fetching view mode:", error);
  }

  await fetchNews();
        setInterval(fetchNews, 10000);
}

window.onload = init;




	function toggleImportApiPopup() {
  const importApiContainer = document.getElementById("import-api-container");
  if (importApiContainer.style.display === "block") {
    importApiContainer.style.display = "none";
  } else {
    importApiContainer.style.display = "block";
    document.getElementById("xtreme-url").focus();
  }
}

async function importChannelsFromApi() {
  const url = document.getElementById("xtreme-url").value.trim();
  const username = document.getElementById("xtreme-username").value.trim();
  const password = document.getElementById("xtreme-password").value.trim();

  if (!url || !username || !password) {
    alert(currentLanguage === "th" ? "กรุณากรอกข้อมูลให้ครบถ้วน" : "Please fill in all fields");
    return;
  }

  try {
    const channels = await window.electronAPI.importChannelsFromApi({
      apiSource: "xtreme",
      url,
      username,
      password,
    });
    console.log(`Imported ${channels.length} channels from Xtream Codes`);
    toggleImportApiPopup();
  } catch (error) {
    console.error("Failed to import from Xtream Codes:", error);
    alert(currentLanguage === "th" ? `นำเข้าล้มเหลว: ${error.message}` : `Import failed: ${error.message}`);
  }
}
	
	
	
	

    async function openFolder() {
        try {
            const files = await window.electronAPI.openFolderDialog();
            if (files && files.length > 0) {
                folderMedia = files;
                renderFolderMedia();
                console.log(`เลือกไฟล์มีเดียจากโฟลเดอร์: ${files.length} ไฟล์`);
            }
        } catch (error) {
            console.error('Failed to open folder:', error);
        }
    }

    window.electronAPI.onTriggerOpenFolder(() => {
        console.log('ได้รับคำสั่งเปิดโฟลเดอร์จากเมนู');
        openFolder();
    });

    if (window.electronAPI?.onFolderMediaSelected) {
        window.electronAPI.onFolderMediaSelected((files) => {
            console.log(`เลือกไฟล์มีเดียจากโฟลเดอร์: ${files.length} ไฟล์`);
            folderMedia = files;
            renderFolderMedia();
        });
    }

    function renderFolderMedia() {
        const channelList = document.getElementById("channel-list");
        channelList.innerHTML = "";

        if (folderMedia.length === 0) {
            channelList.innerHTML = `
                <div class="welcome-container">
                    <img src="assets/welcome-image.png" alt="Welcome" onerror="this.src='assets/tv-app.png'">
                    <p>${currentLanguage === 'th' ? 'ไม่มีไฟล์ในโฟลเดอร์<br>กรุณาเลือกโฟลเดอร์ที่มีไฟล์มีเดีย' : 'No files in folder<br>Please select a folder with media files'}</p>
                </div>
            `;
            return;
        }

        filteredChannels = folderMedia;
        filteredChannels.forEach((media, index) => {
            const channelDiv = document.createElement("div");
            channelDiv.className = "channel";
            channelDiv.draggable = true;
            channelDiv.dataset.index = index;

            const nameSpan = document.createElement("span");
            nameSpan.textContent = media.name;
            nameSpan.contentEditable = true;
            nameSpan.className = "editable-name";
            nameSpan.title = currentLanguage === 'th' ? "คลิกเพื่อแก้ไขชื่อ" : "Click to edit name";

            nameSpan.addEventListener("blur", () => {
                const newName = nameSpan.textContent.trim();
                if (newName && newName !== media.name) {
                    media.name = newName;
                    nameSpan.textContent = newName;
                }
            });

            nameSpan.addEventListener("keydown", (e) => {
                if (e.key === "Enter") {
                    e.preventDefault();
                    nameSpan.blur();
                }
            });

            channelDiv.innerHTML = `<img src="${media.logo}" alt="${media.name}">`;
            channelDiv.appendChild(document.createElement("br"));
            channelDiv.appendChild(nameSpan);
            channelDiv.onclick = (e) => {
                if (e.target !== nameSpan) {
                    showPlayer(media, index);
                }
            };
            channelList.appendChild(channelDiv);
        });

        currentGroup = 'Folder Media';
        renderGroups();
        enableDragAndDrop();
    }

    function sortChannels(order) {
        if (!filteredChannels.length) {
            console.log("No channels to sort.");
            return;
        }

        if (!originalFilteredChannels.length) {
            originalFilteredChannels = [...filteredChannels];
        }

        if (order === 'asc') {
            filteredChannels.sort((a, b) => (a.name || '').localeCompare(b.name || ''));
        } else if (order === 'desc') {
            filteredChannels.sort((a, b) => (b.name || '').localeCompare(a.name || ''));
        } else if (order === 'default') {
            filteredChannels = [...originalFilteredChannels];
        }

        renderChannelsFromFiltered();
    }
function updateScrollButtons() {
        const channelList = document.getElementById("channel-list");
        const scrollUpBtn = document.getElementById("scroll-up-btn");
        const scrollDownBtn = document.getElementById("scroll-down-btn");

        if (!channelList || !scrollUpBtn || !scrollDownBtn) return;

        const scrollTop = channelList.scrollTop;
        const scrollHeight = channelList.scrollHeight;
        const clientHeight = channelList.clientHeight;

        scrollUpBtn.disabled = scrollTop <= 0;
        scrollDownBtn.disabled = scrollTop + clientHeight >= scrollHeight;
    }

    function scrollChannelList(direction) {
        const channelList = document.getElementById("channel-list");
        if (!channelList) return;

        const scrollAmount = 100; // จำนวนพิกเซลที่เลื่อนต่อครั้ง (ปรับได้)
        const currentScroll = channelList.scrollTop;

        if (direction === 'up') {
            channelList.scrollTop = Math.max(0, currentScroll - scrollAmount);
        } else if (direction === 'down') {
            channelList.scrollTop = currentScroll + scrollAmount;
        }

        updateScrollButtons();
    }

function renderChannelsFromFiltered() {
    const channelList = document.getElementById("channel-list");
    if (!filteredChannels || filteredChannels.length === 0) {
        channelList.innerHTML = `
            <div class="welcome-container">
                <img src="assets/welcome-image.png" alt="Welcome" onerror="this.src='assets/tv-app.png'">
                <p>${currentLanguage === 'th' ? 'ยินดีต้อนรับสู่ IPTV Player<br>บริจาคสนับสนุนเพื่อพัฒนาโปรแกรมได้ที่ Paypal: sontaya.t@hotmail.com' : 'Welcome to IPTV Player<br>Please import a channel file to get started <br>Donate by paypal : sontaya.t@hotmail.com'}</p>
            </div>
        `;
        updateScrollButtons();
        return;
    }

    channelList.innerHTML = "";

    filteredChannels.forEach((channel, index) => {
        const defaultLogo = "assets/tv-app.png";
        const channelLogo = channel.logo || defaultLogo;

        const channelDiv = document.createElement("div");
        channelDiv.className = "channel";
        channelDiv.draggable = true;
        channelDiv.tabIndex = 0;
        channelDiv.dataset.index = index;

        const img = document.createElement("img");
        img.src = channelLogo.startsWith("data:image/") || channelLogo.startsWith("http") ? channelLogo : `file://${channelLogo}`;
        img.alt = channel.name || "ช่อง " + (index + 1);
        img.onerror = () => img.src = defaultLogo;

        const nameSpan = document.createElement("span");
        nameSpan.textContent = channel.name || "ช่อง " + (index + 1);
        nameSpan.className = "editable-name";
        nameSpan.contentEditable = isEditMode; // ตั้งค่า contentEditable ตาม isEditMode

        // เพิ่ม event listener สำหรับการแก้ไขชื่อ
        nameSpan.addEventListener("blur", () => {
            const newName = nameSpan.textContent.trim();
            if (newName && newName !== channel.name) {
                channel.name = newName;
                updateChannel(channel, index); // อัปเดตข้อมูลช่อง
                console.log(`Updated channel name to: ${newName}`);
            }
        });

        nameSpan.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
                e.preventDefault();
                nameSpan.blur(); // ออกจากโหมดแก้ไขเมื่อกด Enter
            }
        });

        channelDiv.appendChild(img);
        channelDiv.appendChild(document.createElement("br"));
        channelDiv.appendChild(nameSpan);

        // ปรับปรุงการจัดการคลิก
        channelDiv.onclick = (e) => {
            if (isEditMode) {
                // ถ้าอยู่ในโหมดแก้ไข
                if (e.target === nameSpan) {
                    // ถ้าคลิกที่ nameSpan ให้หยุดการทำงานของ showPlayer
                    e.stopPropagation();
                    nameSpan.focus(); // โฟกัสที่ nameSpan เพื่อแก้ไข
                } else if (e.target === img) {
                    // ถ้าคลิกที่รูปภาพ ให้เรียก uploadChannelImage
                    e.stopPropagation();
                    uploadChannelImage(channel, index, img);
                }
                // ไม่เรียก showPlayer ในโหมดแก้ไข
            } else {
                // ถ้าไม่อยู่ในโหมดแก้ไข ให้เปิด player ตามปกติ
                showPlayer(channel, index);
            }
        };

        channelDiv.onkeydown = (e) => handleChannelKeydown(e, channel, index);
        channelList.appendChild(channelDiv);
    });

    if (channelList.children.length > 0) channelList.children[0].focus();
    enableDragAndDrop();
    updateScrollButtons();
}

function showImageUploadModal(channel, index, imgElement) {
    const modal = document.getElementById("image-upload-modal");
    const title = document.getElementById("image-upload-title");
    const fileRadio = document.getElementById("upload-file-radio");
    const urlRadio = document.getElementById("use-url-radio");
    const fileSection = document.getElementById("file-upload-section");
    const urlSection = document.getElementById("url-input-section");
    const fileInput = document.getElementById("image-upload-input");
    const urlInput = document.getElementById("image-url-input");
    const saveAsFileCheckbox = document.getElementById("save-as-file-checkbox");
    const confirmBtn = document.getElementById("image-upload-confirm");
    const cancelBtn = document.getElementById("image-upload-cancel");
    const saveAsFileLabel = document.getElementById("save-as-file-label");

    // ตั้งค่าภาษา
    title.textContent = currentLanguage === 'th' ? `เปลี่ยนรูปภาพสำหรับ "${channel.name}"` : `Change image for "${channel.name}"`;
    saveAsFileLabel.textContent = currentLanguage === 'th' ? "บันทึกเป็นไฟล์ในเครื่อง (แนะนำสำหรับภาพใหญ่)" : "Save as file on disk (recommended for large images)";
    urlInput.placeholder = currentLanguage === 'th' ? "กรอก URL รูปภาพ..." : "Enter image URL...";

    // รีเซ็ตค่า
    fileInput.value = "";
    urlInput.value = "";
    fileRadio.checked = true;
    urlRadio.checked = false;
    saveAsFileCheckbox.checked = true;
    fileSection.style.display = "block";
    urlSection.style.display = "none";

    // สลับระหว่าง File และ URL
    fileRadio.onchange = () => {
        fileSection.style.display = "block";
        urlSection.style.display = "none";
        fileInput.focus();
    };
    urlRadio.onchange = () => {
        fileSection.style.display = "none";
        urlSection.style.display = "block";
        urlInput.focus();
    };

    modal.style.display = "flex";
    fileInput.focus();

    const handleUpload = async () => {
        let newImageUrl;

        if (fileRadio.checked) {
            const file = fileInput.files[0];
            if (!file) {
                alert(currentLanguage === 'th' ? "กรุณาเลือกไฟล์ภาพ" : "Please select an image file");
                return;
            }

            const reader = new FileReader();
            reader.onload = async (e) => {
                const base64Data = e.target.result;
                if (saveAsFileCheckbox.checked && window.electronAPI.saveImageFile) {
                    const fileName = `channel_${Date.now()}_${file.name}`;
                    try {
                        newImageUrl = await window.electronAPI.saveImageFile(base64Data, fileName);
                        console.log(`Image saved as File Path: ${newImageUrl}`);
                    } catch (error) {
                        console.error("Failed to save image as file, falling back to Data URL:", error);
                        newImageUrl = base64Data;
                    }
                } else {
                    newImageUrl = base64Data;
                    console.log(`Image stored as Data URL: ${newImageUrl.substring(0, 50)}...`);
                }

                channel.logo = newImageUrl;
                imgElement.src = newImageUrl;
                updateChannel(channel, index);
                console.log(`Updated logo for channel "${channel.name}" to ${newImageUrl}`);
                modal.style.display = "none";
            };
            reader.readAsDataURL(file);
        } else if (urlRadio.checked) {
            newImageUrl = urlInput.value.trim();
            if (!newImageUrl) {
                alert(currentLanguage === 'th' ? "กรุณากรอก URL รูปภาพ" : "Please enter an image URL");
                return;
            }

            // ตรวจสอบว่า URL ถูกต้องหรือไม่ (พื้นฐาน)
            if (!newImageUrl.match(/^https?:\/\/.+\.(jpg|jpeg|png|gif|webp)$/i)) {
                alert(currentLanguage === 'th' ? "URL รูปภาพไม่ถูกต้อง (ต้องเป็น .jpg, .png, .gif, หรือ .webp)" : "Invalid image URL (must be .jpg, .png, .gif, or .webp)");
                return;
            }

            // ทดสอบการโหลด URL
            const imgTest = new Image();
            imgTest.onload = () => {
                channel.logo = newImageUrl;
                imgElement.src = newImageUrl;
                updateChannel(channel, index);
                console.log(`Updated logo for channel "${channel.name}" to URL: ${newImageUrl}`);
                modal.style.display = "none";
            };
            imgTest.onerror = () => {
                alert(currentLanguage === 'th' ? "ไม่สามารถโหลดรูปภาพจาก URL นี้ได้" : "Unable to load image from this URL");
            };
            imgTest.src = newImageUrl;
        }
    };

    confirmBtn.onclick = handleUpload;
    fileInput.onchange = () => confirmBtn.focus();
    urlInput.oninput = () => confirmBtn.focus();
    cancelBtn.onclick = () => modal.style.display = "none";

    // รองรับการกด Enter และ Escape
    modal.onkeydown = (e) => {
        if (e.key === "Enter") {
            e.preventDefault();
            handleUpload();
        } else if (e.key === "Escape") {
            modal.style.display = "none";
        }
    };
}

function uploadChannelImage(channel, index, imgElement) {
    if (isEditMode) {
        showImageUploadModal(channel, index, imgElement);
    }
}

function handleChannelKeydown(e, channel, index) {
    const channelDiv = e.target;
    const isGridView = !document.getElementById("channel-list").classList.contains("list-view");

    if (e.key === "Enter") {
        showPlayer(channel, index);
    } else if (e.key === "ArrowDown") {
        e.preventDefault();
        const nextChannel = isGridView ? getNextChannelGrid(channelDiv) : channelDiv.nextElementSibling;
        if (nextChannel) nextChannel.focus();
    } else if (e.key === "ArrowUp") {
        e.preventDefault();
        const prevChannel = isGridView ? getPrevChannelGrid(channelDiv) : channelDiv.previousElementSibling;
        if (prevChannel) prevChannel.focus();
    } else if (e.key === "ArrowRight" && isGridView) {
        e.preventDefault();
        const nextChannel = channelDiv.nextElementSibling;
        if (nextChannel) nextChannel.focus();
    } else if (e.key === "ArrowLeft" && isGridView) {
        e.preventDefault();
        const prevChannel = channelDiv.previousElementSibling;
        if (prevChannel) prevChannel.focus();
    } else if (e.key === "Backspace") { // เพิ่มการย้อนกลับไป Group List
        e.preventDefault();
        const groupList = document.getElementById("group-list");
        const activeGroup = [...groupList.children].find(g => g.textContent === currentGroup);
        if (activeGroup) {
            activeGroup.focus();
        } else {
            groupList.children[0]?.focus(); // ถ้าไม่พบกลุ่มปัจจุบัน โฟกัสกลุ่มแรก
        }
    }
}



    function enableDragAndDrop() {
        const channelList = document.getElementById("channel-list");

        channelList.addEventListener('dragstart', (e) => {
            const channel = e.target.closest('.channel');
            if (!channel) return;
            channel.classList.add('dragging');
            e.dataTransfer.setData('text/plain', channel.dataset.index);
        });

        channelList.addEventListener('dragend', (e) => {
            const channel = e.target.closest('.channel');
            if (channel) {
                channel.classList.remove('dragging');
            }
        });

        channelList.addEventListener('dragover', (e) => {
            e.preventDefault();
        });

        channelList.addEventListener('drop', (e) => {
            e.preventDefault();
            const fromIndex = parseInt(e.dataTransfer.getData('text/plain'), 10);
            const toElement = e.target.closest('.channel');
            if (!toElement) return;

            const toIndex = parseInt(toElement.dataset.index, 10);

            if (fromIndex !== toIndex) {
                const [movedChannel] = filteredChannels.splice(fromIndex, 1);
                filteredChannels.splice(toIndex, 0, movedChannel);
                renderChannelsFromFiltered();
                console.log(`Moved channel from index ${fromIndex} to ${toIndex}`);
            }
        });
    }
	
document.getElementById('screenshot-btn').addEventListener('click', async () => {
    try {
        console.log('Capturing screenshot...');
        const screenshotData = await window.electronAPI.captureScreenshot();
        if (!screenshotData) {
            throw new Error('No screenshot data received');
        }
        console.log('Screenshot captured, data length:', screenshotData.length);

        const modal = document.getElementById('screenshot-preview-modal');
        const previewImg = document.getElementById('screenshot-preview-img');
        previewImg.src = screenshotData;
        modal.style.display = 'flex';

        document.getElementById('screenshot-save-btn').onclick = async () => {
            try {
                console.log('Saving screenshot...');
                const success = await window.electronAPI.saveScreenshot(screenshotData);
                modal.style.display = 'none';
                if (success) {
                    console.log('Screenshot saved successfully');
                } else {
                    console.log('Screenshot save cancelled');
                }
            } catch (error) {
                console.error('Failed to save screenshot:', error);
                alert('ไม่สามารถบันทึกภาพได้: ' + error.message);
            }
        };

        document.getElementById('screenshot-cancel-btn').onclick = () => {
            modal.style.display = 'none';
            console.log('Screenshot capture cancelled');
        };

        modal.onkeydown = (e) => {
            if (e.key === 'Escape') {
                modal.style.display = 'none';
            }
        };
    } catch (error) {
        console.error('Failed to capture screenshot:', error);
        alert('ไม่สามารถจับภาพหน้าจอได้: ' + error.message);
    }
});

document.getElementById("download-btn").onclick = async () => {
    console.log("Download button clicked");
    console.log("currentChannelIndex:", currentChannelIndex);
    console.log("filteredChannels:", filteredChannels);
    console.log("currentStreamMedia:", currentStreamMedia);
    console.log("favoriteChannels:", favoriteChannels);

    let currentChannel = filteredChannels[currentChannelIndex] || currentStreamMedia;
    if (!currentChannel && currentGroup === (currentLanguage === 'th' ? "รายการโปรด" : "Favorites")) {
        currentChannel = favoriteChannels[currentChannelIndex];
        console.log("Using favoriteChannels as fallback:", currentChannel);
    }

    if (!currentChannel) {
        console.log("No channel selected for download");
        if (filteredChannels.length === 0 && favoriteChannels.length === 0) {
            alert(currentLanguage === "th" ? "กรุณานำเข้าช่องรายการก่อนดาวน์โหลด" : "Please import channels before downloading");
        } else if (currentChannelIndex < 0 || currentChannelIndex >= Math.max(filteredChannels.length, favoriteChannels.length)) {
            alert(currentLanguage === "th" ? "กรุณาเลือกช่องก่อนดาวน์โหลด" : "Please select a channel before downloading");
        } else {
            alert(currentLanguage === "th" ? "ไม่มีวิดีโอให้ดาวน์โหลด" : "No video to download");
        }
        return;
    }

    // กรณี YouTube Embed
    if (currentChannel.embed && currentChannel.file.includes("youtube.com/embed")) {
        const videoIdMatch = currentChannel.file.match(/youtube\.com\/embed\/([^?]+)/);
        const videoId = videoIdMatch ? videoIdMatch[1] : null;
        if (videoId) {
            console.log("Detected YouTube video, videoId:", videoId);
            await downloadYouTubeVideo(videoId);
            return;
        } else {
            console.log("Invalid YouTube URL:", currentChannel.file);
            alert(currentLanguage === "th" ? "URL YouTube ไม่ถูกต้อง" : "Invalid YouTube URL");
            return;
        }
    }

    // กรณี .m3u8 หรือวิดีโออื่น
    const playerInstance = jwplayer("player");
    let videoUrl;

    if (playerInstance.getState()) {
        videoUrl = playerInstance.getPlaylistItem().file;
        console.log("Using JW Player URL:", videoUrl);
    } else {
        videoUrl = currentChannel.file;
        console.log("Using channel file URL:", videoUrl);
    }

    if (!videoUrl || !videoUrl.includes(".m3u8")) {
        console.log("Unsupported or invalid video format for download:", videoUrl);
        alert(currentLanguage === "th" ? "ไม่สามารถดาวน์โหลดวิดีโอประเภทนี้ได้ (รองรับเฉพาะ .m3u8)" : "Cannot download this video type (only .m3u8 supported)");
        return;
    }

    const defaultFileName = `${currentChannel.name.replace(/[\\/:*?"<>|]/g, "_")}.mp4`;
    console.log("Opening save dialog...");
    const { canceled, filePath } = await window.electronAPI.invoke("show-save-dialog", {
        defaultPath: defaultFileName,
        filters: [{ name: "Video Files", extensions: ["mp4"] }],
    });

    if (canceled || !filePath) {
        console.log("User cancelled save dialog");
        return;
    }

    console.log("Save path selected:", filePath);

    const durationModal = document.createElement("div");
    durationModal.style.cssText = "position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1e1e1e; padding: 20px; border-radius: 10px; color: #fff; z-index: 2000;";
    durationModal.innerHTML = `
        <p>${currentLanguage === "th" ? "ระบุระยะเวลาการดาวน์โหลด (วินาที, ว่างไว้เพื่อไม่จำกัด):" : "Specify download duration (seconds, leave blank for unlimited):"}</p>
        <input type="number" id="download-duration" style="width: 100px; padding: 5px;" placeholder="เช่น 60">
        <div style="margin-top: 10px;">
            <button id="start-download-btn" style="padding: 5px 10px; background: #28a745; border: none; border-radius: 5px; color: #fff; cursor: pointer;">เริ่ม</button>
            <button id="cancel-duration-btn" style="padding: 5px 10px; background: #dc3545; border: none; border-radius: 5px; color: #fff; cursor: pointer;">ยกเลิก</button>
        </div>
    `;
    document.body.appendChild(durationModal);

    const startButton = durationModal.querySelector("#start-download-btn");
    const cancelButton = durationModal.querySelector("#cancel-duration-btn");

    const downloadDuration = await new Promise((resolve) => {
        startButton.onclick = () => {
            const durationInput = durationModal.querySelector("#download-duration").value;
            const duration = durationInput ? parseInt(durationInput, 10) : null;
            console.log("Duration selected:", duration);
            document.body.removeChild(durationModal);
            resolve(duration);
        };

        cancelButton.onclick = () => {
            console.log("Duration selection cancelled");
            document.body.removeChild(durationModal);
            resolve(null);
        };
    });

    if (downloadDuration === null) {
        console.log("No duration specified, proceeding with unlimited download");
    } else {
        console.log("Proceeding with duration:", downloadDuration);
    }

    let progressModal;
    let isDownloadCompleted = false;

    try {
        console.log("Creating progress modal...");
        progressModal = document.createElement("div");
        progressModal.style.cssText = `
            position: fixed; 
            bottom: 20px; 
            right: 20px; 
            background: rgba(30, 30, 30, 0.8); 
            padding: 10px 15px; 
            border-radius: 5px; 
            color: #fff; 
            z-index: 2000; 
            font-size: 14px; 
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        `;
        progressModal.innerHTML = `
            <p style="margin: 0;">Downloading: <span id="download-progress">0%</span></p>
            <button id="stop-download-btn" style="margin-top: 5px; padding: 3px 8px; background: #dc3545; border: none; border-radius: 3px; color: #fff; cursor: pointer; font-size: 12px;">หยุด</button>
        `;
        document.body.appendChild(progressModal);
        console.log("Progress modal added to DOM");

        const stopButton = progressModal.querySelector("#stop-download-btn");
        let isStopping = false;
        stopButton.onclick = async () => {
            if (isStopping) return;
            isStopping = true;
            stopButton.disabled = true;
            stopButton.style.opacity = "0.5";
            console.log("Stop download button clicked");
            try {
                await window.electronAPI.stopDownload();
                console.log("Stop download requested");
                document.body.removeChild(progressModal);
            } catch (error) {
                console.error("Error stopping download:", error);
                document.body.removeChild(progressModal);
                showErrorModal(currentLanguage === "th" ? `หยุดดาวน์โหลดล้มเหลว: ${error.message}` : `Failed to stop download: ${error.message}`);
            }
        };

        console.log("Setting up event listeners...");
        const onProgress = (progress) => {
            console.log("Download progress received:", progress);
            if (document.getElementById("download-progress")) {
                document.getElementById("download-progress").textContent = `${progress.percent}% (${progress.timemark})`;
            }
        };

        const onComplete = (filePath) => {
            if (isDownloadCompleted) return;
            isDownloadCompleted = true;
            console.log("Download complete:", filePath);
            document.body.removeChild(progressModal);
            showSuccessModal(currentLanguage === "th" ? `ดาวน์โหลดสำเร็จ: ${filePath}` : `Download complete: ${filePath}`);
            cleanupListeners();
        };

        const onError = (error) => {
            if (isDownloadCompleted) return;
            console.error("Download error received:", error);
            document.body.removeChild(progressModal);
            showErrorModal(currentLanguage === "th" ? `ดาวน์โหลดล้มเหลว: ${error}` : `Download failed: ${error}`);
            cleanupListeners();
        };

        window.electronAPI.onDownloadProgress(onProgress);
        window.electronAPI.onDownloadComplete(onComplete);
        window.electronAPI.onDownloadError(onError);

        function cleanupListeners() {
            window.electronAPI.off("download-progress", onProgress);
            window.electronAPI.off("download-complete", onComplete);
            window.electronAPI.off("download-error", onError);
            console.log("Event listeners cleaned up");
        }

        if (videoUrl.includes("24playerhd.com") || currentChannel.httpOptions?.referrer) {
            const port = await window.electronAPI.startProxy(videoUrl);
            videoUrl = `http://localhost:${port}/m3u8?url=${encodeURIComponent(videoUrl)}`;
            console.log("Proxy started, updated video URL:", videoUrl);
        }

        console.log("Calling downloadVideo with URL:", videoUrl, "to:", filePath, "duration:", downloadDuration);
        const result = await window.electronAPI.downloadVideo(videoUrl, filePath, downloadDuration);
        console.log("Download function completed successfully with result:", result);
        if (!isDownloadCompleted) {
            onComplete(filePath);
        }
    } catch (error) {
        console.error("Error during download process:", error.message, error.stack);
        if (progressModal && document.body.contains(progressModal)) {
            document.body.removeChild(progressModal);
        }
        showErrorModal(currentLanguage === "th" ? `เกิดข้อผิดพลาด: ${error.message}` : `Error: ${error.message}`);
    }
};




function showSuccessModal(message) {
    const modal = document.createElement("div");
    modal.style.cssText = `
        position: fixed; 
        top: 50%; 
        left: 50%; 
        transform: translate(-50%, -50%); 
        background: #1e1e1e; 
        padding: 20px; 
        border-radius: 10px; 
        color: #fff; 
        z-index: 2000; 
        text-align: center;
        box-shadow: 0 4px 10px rgba(255, 255, 255, 0.1);
    `;
    modal.innerHTML = `
        <p style="margin: 0 0 15px 0;">${message}</p>
        <button id="modal-ok-btn" style="padding: 8px 15px; background: #28a745; border: none; border-radius: 5px; color: #fff; cursor: pointer;">ตกลง</button>
    `;
    document.body.appendChild(modal);

    const okButton = modal.querySelector("#modal-ok-btn");
    okButton.focus();
    okButton.onclick = () => {
        document.body.removeChild(modal);
    };
    modal.onkeydown = (e) => {
        if (e.key === "Enter" || e.key === "Escape") {
            document.body.removeChild(modal);
        }
    };
}

function showErrorModal(message) {
    const modal = document.createElement("div");
    modal.style.cssText = `
        position: fixed; 
        top: 50%; 
        left: 50%; 
        transform: translate(-50%, -50%); 
        background: #1e1e1e; 
        padding: 20px; 
        border-radius: 10px; 
        color: #fff; 
        z-index: 2000; 
        text-align: center;
        box-shadow: 0 4px 10px rgba(255, 255, 255, 0.1);
    `;
    modal.innerHTML = `
        <p style="margin: 0 0 15px 0;">${message}</p>
        <button id="modal-ok-btn" style="padding: 8px 15px; background: #dc3545; border: none; border-radius: 5px; color: #fff; cursor: pointer;">ตกลง</button>
    `;
    document.body.appendChild(modal);

    const okButton = modal.querySelector("#modal-ok-btn");
    okButton.focus();
    okButton.onclick = () => {
        document.body.removeChild(modal);
    };
    modal.onkeydown = (e) => {
        if (e.key === "Enter" || e.key === "Escape") {
            document.body.removeChild(modal);
        }
    };
}
    window.onload = init;
	
	
	if (window.electronAPI) {
        window.electronAPI.on('paste-from-clipboard', (event, text) => {
            const activeElement = document.activeElement;
            if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA')) {
                activeElement.value = text;
                console.log(`Pasted "${text}" into ${activeElement.id || activeElement.tagName}`);
                if (activeElement.id === 'search-input') {
                    const query = activeElement.value.trim();
                    if (query) renderChannels(`search:${query}`);
                    else renderChannels(currentGroup);
                }
            }
        });
    }

</script>
	
	<footer id="footer">
        <div id="news-ticker">
    <marquee id="news-marquee" behavior="scroll" direction="left" scrollamount="5">กำลังโหลดข่าวสั้น...</marquee>
		</div>
    </footer>
	<div id="screenshot-preview-modal">
    <div id="screenshot-preview-container">
        <img id="screenshot-preview-img" src="" alt="Screenshot Preview">
        <div id="screenshot-preview-buttons">
            <button id="screenshot-save-btn">บันทึก</button>
            <button id="screenshot-cancel-btn">ยกเลิก</button>
        </div>
    </div>
</div>
<!-- เพิ่มในส่วนท้ายของ <body> ก่อน </body> -->
<!-- แทนที่ modal เดิมด้วยโค้ดนี้ -->
<div id="image-upload-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; background: rgba(0, 0, 0, 0.8); z-index: 2000; justify-content: center; align-items: center;">
    <div id="image-upload-container" style="background: #1e1e1e; padding: 20px; border-radius: 10px; text-align: center; box-shadow: 0 4px 10px rgba(255, 255, 255, 0.1);">
        <h3 id="image-upload-title" style="color: #fff; margin-bottom: 15px;"></h3>
        <div style="margin-bottom: 15px;">
            <input type="radio" id="upload-file-radio" name="image-source" value="file" checked style="margin-right: 5px;">
            <label for="upload-file-radio" style="color: #fff;">อัปโหลดไฟล์</label>
            <input type="radio" id="use-url-radio" name="image-source" value="url" style="margin-left: 15px; margin-right: 5px;">
            <label for="use-url-radio" style="color: #fff;">ใช้ URL</label>
        </div>
        <div id="file-upload-section">
            <input type="file" id="image-upload-input" accept="image/*" style="display: block; margin: 0 auto 15px;">
            <label style="color: #fff; display: block; margin-bottom: 10px;">
                <input type="checkbox" id="save-as-file-checkbox" checked>
                <span id="save-as-file-label">บันทึกเป็นไฟล์ในเครื่อง (แนะนำสำหรับภาพใหญ่)</span>
            </label>
        </div>
        <div id="url-input-section" style="display: none;">
            <input type="text" id="image-url-input" placeholder="กรอก URL รูปภาพ..." style="display: block; margin: 0 auto 15px; padding: 8px; border: none; border-radius: 3px; background: #333; color: #fff; width: 250px; outline: none;">
        </div>
        <div style="display: flex; justify-content: center; gap: 10px;">
            <button id="image-upload-confirm" style="padding: 8px 15px; background: #28a745; border: none; border-radius: 5px; color: #fff; cursor: pointer;">ตกลง</button>
            <button id="image-upload-cancel" style="padding: 8px 15px; background: #dc3545; border: none; border-radius: 5px; color: #fff; cursor: pointer;">ยกเลิก</button>
        </div>
    </div>
</div>
<!-- ในส่วน <body> -->
<div id="import-api-container" style="display: none; position: absolute; top: 90px; right: 20px; background: #1e1e1e; padding: 10px; border-radius: 5px; box-shadow: 0px 4px 10px rgba(255, 255, 255, 0.1); z-index: 100;">
    <input type="text" id="xtreme-url" placeholder="Server URL (เช่น http://example.com:8080)" style="padding: 8px; border: none; border-radius: 3px; background: #333; color: #fff; width: 200px; outline: none; margin-bottom: 5px;">
    <input type="text" id="xtreme-username" placeholder="Username" style="padding: 8px; border: none; border-radius: 3px; background: #333; color: #fff; width: 200px; outline: none; margin-bottom: 5px;">
    <input type="password" id="xtreme-password" placeholder="Password" style="padding: 8px; border: none; border-radius: 3px; background: #333; color: #fff; width: 200px; outline: none; margin-bottom: 5px;">
    <button id="import-api-btn" style="margin-left: 10px; padding: 8px 15px; background: #007bff; border: none; border-radius: 3px; color: #fff; cursor: pointer;">นำเข้า</button>
    <button id="close-import-api" style="margin-left: 10px; padding: 8px 15px; background: #ff4444; border: none; border-radius: 3px; color: #fff; cursor: pointer;">ปิด</button>
</div>

<div id="import-progress-modal" style="display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #1e1e1e; padding: 20px; border-radius: 10px; color: #fff; z-index: 2000; text-align: center;">
    <p>กำลังนำเข้าช่อง...</p>
    <div id="progress-bar" style="width: 300px; height: 20px; background: #333; border-radius: 10px; overflow: hidden;">
        <div id="progress-fill" style="width: 0%; height: 100%; background: #007bff; transition: width 0.3s;"></div>
    </div>
    <p id="progress-text">0%</p>
</div>
</body>
</html>
